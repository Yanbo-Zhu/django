
# 1 视图

视图一般都写在app 的views.py 中。并且视图的第一个参数永远都是request （一个 HttpRequest）对象。这个对象存储了请求过来的所有信息，包括携带的参数以及一些头部信息等。在视图中，一般是完成逻辑相关的操作。
比如这个请求是添加一篇博客，那么可以通过request来接收到这些数据，然后存储到数据库中，最后再把执行的结果返回给浏览器。视图函数的返回结果必须是 HttpResponseBase 对象或者子类的对象。

示例代码如下：

```
from django.http import HttpResponse
def book_list(request):
return HttpResponse("书籍列表！")
```

视图可以是函数，也可以是类，我们先学习函数视图，后面再学习类视图。


# 2 MTV模型
视图(Views）是 Django的 MTV架构模式的V部分，主要负责处理用户请求和生成相应的响应内容,然后
在页面或其他类型文档中显示。
Django的MTV分别代表：
Model(模型)：业务对象与数据库的对象(ORM)
Template(模版)：负责如何把页面展示给用户
View(视图)：负责业务逻辑，并在适当的时候调用Model和Template

![[05_视图View/images/Pasted image 20240619145630.png]]


# 3 Django5设置视图响应状态

客户端请求后端服务，在view.py视图层方法最终return 返回视图响应。Python内置提供了响应类型，
来实现不同的返回不同的http状态码；


响应类型   解释说明
HttpResponse('Hello world'") 状态码200，请求已成功被服务器接收
HttpResponseRedirect('/') 状态码302，重定向首页地址
HttpResponsePermanentRedirect('/') 状态码301，永久重定向首页地址
HttpResponseBadRequest("'400') 状态码400，访问的页面不存在或请求错误
HttpResponseNotFound('404") 状态码404，网页不存在或网页的URL失效
HttpResponseForbidden('403') 状态码403，没有访问权限
HttpResponseNotAllowed('405') 状态码405，不允许使用该请求方式
HttpResponseServerError('500'") 状态码500，服务器内容错误
JsonResponse( {'foo' : 'bar'}) 默认状态码200，响应内容为JSON数据
StreamingHttpResponse() 默认状态码200，响应内容以流式输出


举例一：HttpResponse
修改helloWorld的views.py的index函数：
```
def index(request):
	html = "<font color='red'>学Python，上www.python222.com</font>"
	return HttpResponse(html, status=200)
```
![[05_视图View/images/Pasted image 20240619145826.png]]
请求测试，状态码200，返回网页信息。status=200不写的话默认也是200.



举例二：HttpResponseNotFound 404
```
def index(request):
	return HttpResponseNotFound()
```
![[05_视图View/images/Pasted image 20240619145903.png]]
请求测试，状态码404。


举例三：JsonResponse 响应json数据
```
def index(request):
	return JsonResponse({'foo': 'bar'})
```
![[05_视图View/images/Pasted image 20240619145927.png]]
请求测试，状态码200，返回json格式数据。


## 3.1 HttpResponse: 渲染网页 

我们第一个实例用到的是HttpResponse，简单网页我们直接可以响应到页面，但是假如是复杂网页，就会增加视图函数的代码量。所以我们引入模版，通过django提供的render方法渲染数据到模版，然后再响应到页面。

```
def index(request):
	return render(request, 'index.html')
```

这个是我们前面的的HelloWorld代码，我们ctrl点进去render方法，看下源码：
![[05_视图View/images/Pasted image 20240619150138.png]]
经过模版渲染后得到content网页内容，依然返回的是HttpResponse对象。

render方法定义：
```
def render(
	request, template_name, context=None, content_type=None, status=None,
using=None
):
```

request和template_name是必须的参数。其他参数可选。
- request:浏览器向服务器发送的请求对象，包含用户信息、请求内容和请求方式等。
- template_name:设置模板文件名，用于生成网页内容。
- context:对模板上下文（模板变量）赋值，以字典格式表示，默认情况下是一个空字典。
- content_type:响应内容的数据格式，一般情况下使用默认值即可。
- status: HTTP状态码，默认为200.
- using:设置模板引擎，用于解析模板文件，生成网页内容。


我们再写一个带字典参数的render渲染模版实例：
views.py改写下：
```
def index(request):
	content_value = {"msg": '学Python，上www.python222.com'}
	return render(request, 'index.html', context=content_value)
```

模版代码改写下，模版里取值语法 {{ 字典的key值 }}
```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
</head>
<body>
模版取值： {{ msg }}
</body>
</html>
```

# 4 HttpResponse对象

Django服务器接收到客户端发送过来的请求后，会将提交上来的这些数据封装成一个HttpRequest 对象传给视图函数。那么视图函数在处理完相关的逻辑后，也需要返回一个响应给浏览器。而这个响应，我们必须返回HttpResponseBase 或者他的子类的对象。而HttpResponse 则是HttpResponseBase 用得最多的子类。\

那么接下来就来介绍一下HttpResponse 及其子类

## 4.1 常用属性：
1. content：返回的内容。
2. status_code：返回的HTTP响应状态码。
3. content_type：返回的数据的MIME类型，默认为text/html 。浏览器会根据这个属性，来显示数据。如果是text/html ，那么就会解析这个字符串，如果text/plain ，那么就会显示一个纯文本。常用的Content-Type 如下：
    1. text/html（默认的，html文件）
    2. text/plain（纯文本）
    3. text/css（css文件）
    4. text/javascript（js文件）
    5. multipart/form-data（文件提交）
    6. application/json（json传输）
    7. application/xml（xml文件）
4. 设置请求头： response['X-Access-Token'] = 'xxxx' 。


## 4.2 常用方法：
1. set_cookie：用来设置cookie 信息。后面讲到授权的时候会着重讲到。
2. delete_cookie：用来删除cookie 信息。
3. write： HttpResponse 是一个类似于文件的对象，可以用来写入数据到数据体（content）中。


## 4.3 JsonResponse类：

用来对象 dump 成json 字符串，然后返回将json 字符串封装成Response 对象返回给浏览器。并且他的Content-Type 是application/json 。示例代码如下
```
from django.http import JsonResponse

def index(request):
    return JsonResponse({"username":"zhiliao","age":18})
```


默认情况下JsonResponse 只能对字典进行dump ，如果想要对非字典的数据进行dump ，那么需要给JsonResponse 传递一个safe=False 参数
```
from django.http import JsonResponse

def index(request):
    persons = ['张三','李四','王五']
    return HttpResponse(persons)
```

以上代码会报错，应该在使用HttpResponse 的时候，传入一个safe=False 参数，示例代码如下：
`return HttpResponse(persons,safe=False)`


# 5 Http请求&HttpRequest请求类

超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。

当在浏览器上访问某个网址时，其实质是向网站发送一个HTTP请求，HTTP请求分为8种请求方式，每种请求方式的说明如下：

请求方式 说明
OPTIONS 返回服务器针对特定资源所支持的请求方法
GET 向特定资源发出请求（访问网页）
POST 向指定资源提交数据处理请求（提交表单、上传文件)
PUT 向指定资源位置上传数据内容
DELETE 请求服务器删除request-URL所标示的资源
HEAD 与GET请求类似，返回的响应中没有具体内容，用于获取报头
TRACE 回复和显示服务器收到的请求，用于测试和诊断
CONNECT HTTP/1.1协议中能够将连接改为管道方式的代理服务器


在上述的HTTP请求方式里，最基本的是GET请求和POST 请求，网站开发者关心的也只有GET请求和 POST请求。GET请求和 POST请求是可以设置请求参数的，两者的设置方式如下:
- GET请求的请求参数是在路由地址后添加“?”和参数内容，参数内容以key=value 形式表示，等号前面的是参数名，后面的是参数值，如果涉及多个参数，每个参数之间就使用“&”隔开，如127.0.0.1:8000/?name=python222&pw=123456。
- POST请求的请求参数一般以表单的形式传递，常见的表单使用HTML的 form标签，并且form标签的method 属性设为POST.

再Django5中，Http请求信息都被封装到了HttpRequest类中。

HttpRequest类的常用属性如下：
- COOKIE:获取客户端（浏览器）的Cookie信息，以字典形式表示，并且键值对都是字符串类型。
- FILES: django.http.request.QueryDict对象，包含所有的文件上传信息。
- GET:获取GET请求的请求参数，它是django.http.request.QueryDict对象，操作起来类似于字典。
- POST:获取POST请求的请求参数，它是django.http.request.QueryDict对象，操作起来类似于字典
- META:获取客户端（浏览器）的请求头信息，以字典形式存储。
- method:获取当前请求的请求方式(GET请求或POST请求).
- path:获取当前请求的路由地址。
- session:一个类似于字典的对象，用来操作服务器的会话信息，可临时存放用户信息。
- user:当 Django启用AuthenticationMiddleware中间件时才可用。它的值是内置数据模型User的对象，表示当前登录的用户。如果用户当前没有登录，那么user将设为 django.contrib.auth.models.AnonymousUser的一个实例。

HttpRequest类常用方法如下：
- is_secure():是否是采用HTTPS协议。
- get_host():获取服务器的域名。如果在访问的时候设有端口，就会加上端口号，如 127.0.0.1:8000。
- get_full path():返回路由地址。如果该请求为GET请求并且设有请求参数，返回路由地址就会将请求参数返回，如/?name=python222&pw=123456。


## 5.1 例子

先views.py里定义两个方法，分别测试get和post：

```python
def get_test(request):
	"""
	get请求测试
	:param request:
	:return:
	"""
	print(request.method) # 请求方式
	# 常用属性
	print(request.content_type)
	print(request.content_params)
	print(request.COOKIES)
	print(request.scheme)
	# 常用方法
	print(request.is_secure())
	print(request.get_host())
	print(request.get_full_path())
	print(request.GET.get("name"))
	print(request.GET.get("pwd"))
	print(request.GET.get("aaa", "666"))
	return HttpResponse("http get ok")


def post_test(request):
	"""
	post请求测试
	:param request:
	:return:
	"""
	print(request.method) # 请求方式
	
	print(request.POST.get("name"))
	print(request.POST.get("pwd"))
	print(request.POST.get("aaa", "666"))
	return HttpResponse("http post ok")
```

urls.py里定义下映射：
```
path('get', helloWorld.views.get_test),
path('post', helloWorld.views.post_test)
```

模版里新建http.html，这里我们不能用静态页面，需要一个csrf安全机制token 需要后端server来提
供，所以只能用模版

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
</head>
<body>
<a href="/get?name=python222&pwd=123456" target="_blank">http get请求测试</a><br>
<br>
<form action="/post" method="post">
	{% csrf_token %}
	name:<input type="text" name="name"><br>
	pwd:<input type="text" name="pwd">
	<input type="submit" value="提交"></input>
</form>
</body>
</html>
```


请求index跳转到http.html
```
def index(request):
	return render(request, 'http.html')
```

浏览器输入 http://127.0.0.1:8000/index/ 测试：
![[05_视图View/images/Pasted image 20240619154517.png]]

点击get链接地址：
后台输出：
```
GET
text/plain
{}
{'csrftoken': 'GDgfE2kvXwRYS6WMejaYNE9ij9KPodHi'}
http
False
127.0.0.1:8000
/get?name=python222&pwd=123456
python222
123456
666
请求处理完毕，将返回到页面
[20/Feb/2024 17:09:52] "GET /get?name=python222&pwd=123456 HTTP/1.1" 200 11
```

再post表单测试：
后台输出：
```
POST
python222
123456
666
```


# 6 Django5设置重定向响应


Django重定向我们前面讲过一种urls.py里使用RedirectView实现
```
path('redirectTo', RedirectView.as_view(url="index/"))
```

这种方便书写简单，但是不灵活，我们实际开发，为了能否实现业务上的判断，来进行业务重定向跳转，还是需要用redirect方法。
重定向的状态码分为301和302，前者是永久性跳转的，后者是临时跳转的，两者的区别在于搜索引擎的网页抓取。

重定向分为永久性重定向和暂时性重定向，在页面上体现的操作就是浏览器会从一个页面自动跳转到另外一个页面。比如用户访问了一个需要权限的页面，但是该用户当前并没有登录，因此我们应该给他重定向到登录页面。

永久性重定向：
301重定向是永久的重定向，搜索引擎在抓取新内容的同时会将旧的网址替换为重定向之后的网址。
http的状态码是301，多用于旧网址被废弃了要转到一个新的网址确保用户的访问，最经典的就是京东网站，你输入www.jingdong.com的时候，会被重定向到www.jd.com，因为jingdong.com这个网址已经被废弃了，被改成jd.com，所以这种情况下应该用永久重定向。

暂时性重定向：
http的状态码是302，表示页面的暂时性跳转。比如访问一个需要权限的网址，如果当前用户没有登录，应该重定向到登录页面，这种情况下，应该用暂时性重定向。在Django 中，重定向是使用`redirect(to, *args, permanent=False, **kwargs) `来实现的。to 是一个url ， permanent 代表的是这个重定向是否是一个永久的重定向，默认是False 。
302跳转是暂时的跳转，搜索引擎会抓取新内容而保留旧的网址。因为服务器返回302代码，所以搜索引擎认为新的网址只是暂时的。


Django内置提供了重定向类HttpResponseRedirect和HttpResponsePermanentRedirect分别代表
HTTP状态码302和301

![[05_视图View/images/Pasted image 20240619152113.png]]

## 6.1 例子 

### 6.1.1 

关于重定向的使用，请看以下例子：

```python
from django.shortcuts import reverse,redirect
def profile(request):
    if request.GET.get("username"):
        return HttpResponse("%s，欢迎来到个人中心页面！")
    else:
        return redirect(reverse("user:login"))
```


### 6.1.2 

我们static下面新建一个新页面new.html
![[05_视图View/images/Pasted image 20240619152455.png]]

改写helleWorld里得index方法：

```
def index(request):
	return redirect("/static/new.html")
```

我们测试下：请求 http://127.0.0.1:8000/index/ 302跳转到了new.html页面 （最好用谷歌浏览器得无痕浏览，这样没有缓存干扰测试）

![[05_视图View/images/Pasted image 20240619152535.png]]


我们加上 permanent=True 参数；
```
def index(request):
	return redirect("/static/new.html", permanent=True)
```


再测试下，就变成301永久跳转了。

![[05_视图View/images/Pasted image 20240619152609.png]]


## 6.2 redirect方法的源码

我们点进去看下redirect方法的源码实现：

```
def redirect(to, *args, permanent=False, **kwargs):
"""
Return an HttpResponseRedirect to the appropriate URL for the arguments
passed.
The arguments could be:
* A model: the model's `get_absolute_url()` function will be called.
* A view name, possibly with arguments: `urls.reverse()` will be used
to reverse-resolve the name.

* A URL, which will be used as-is for the redirect location.
Issues a temporary redirect by default; pass permanent=True to issue a
permanent redirect.
"""

redirect_class = (
	HttpResponsePermanentRedirect if permanent else HttpResponseRedirect
)
return redirect_class(resolve_url(to, *args, **kwargs))
```

第一个跳转参数支持模型，视图路由名称，还有最常用得url地址；第二个参数就是是否永久跳转，默认
Flase；
redirect_class通过permanent判断，true返回HttpResponsePermanentRedirect，false返回
HttpResponseRedirect;


# 7 Django5二进制文件下载

响应内容除了返回网页信息外，还可以实现文件下载功能，是网站常用的功能之一。

Django提供三种方式实现文件下载功能，分别是HttpResponse、StreamingHttpResponse和FileResponse,三者的说明如下:
- HttpResponse是所有响应过程的核心类，它的底层功能类是HttpResponseBase。
- StreamingHttpResponse是在 HttpResponseBase的基础上进行继承与重写的，它实现流式响应输出（流式响应输出是使用Python的迭代器将数据进行分段处理并传输的)，适用于大规模数据响应和文件传输响应。
- FileResponse是在StreamingHttpResponse 的基础上进行继承与重写的，它实现文件的流式响应输出，只适用于文件传输响应。



## 7.1 例子 

我们准备一个文件，这里我们用一个exe二进制文件。放D盘根目录。


views.py里写方法实现方法：
```python
# 定义文件路径
file_path = "D:\\360zip_setup.exe"

def download_file1(request):
	file = open(file_path, 'rb') # 打开文件
	response = HttpResponse(file) # 创建HttpResponse对象
	response['Content_Type'] = 'application/octet-stream'
	response['Content-Disposition'] = 'attachment;filename=file1.exe'
	return response

def download_file2(request):
	file = open(file_path, 'rb') # 打开文件
	response = StreamingHttpResponse(file) # 创建StreamingHttpResponse对象
	response['Content_Type'] = 'application/octet-stream'
	response['Content-Disposition'] = 'attachment;filename=file2.exe'
	return response


def download_file3(request):
	file = open(file_path, 'rb') # 打开文件
	response = FileResponse(file) # 创建FileResponse对象
	response['Content_Type'] = 'application/octet-stream'
	response['Content-Disposition'] = 'attachment;filename=file3.exe'
	return response
```

urls.py里定义下映射：
```
path('download1', helloWorld.views.download_file1),
path('download2', helloWorld.views.download_file2),
path('download3', helloWorld.views.download_file3)
```


为了方便测试，我们static目录下新建一个download.html静态文件：
```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>下载测试</title>
</head>
<body>
<a href="/download1">下载测试一：HttpResponse</a><br>
<a href="/download2">下载测试二：StreamingHttpResponse</a><br>
<a href="/download3">下载测试三：FileResponse</a>
</body>
</html>
```

页面输入： http://127.0.0.1:8000/static/download.html 测试：
![[05_视图View/images/Pasted image 20240619153316.png]]


# 8 Django5文件上传实现

文件上传功能是网站开发或者业务系统常见的功能之一，比如上传图片（用户头像或文章配图）和导入文件（压缩包，视频，音乐)。无论上传的文件是什么格式的，其上传原理都是将文件以二进制的数据格式读取并写入网站或者业务系统指定的目录里。

我们通过一个实例来深入体验学习下文件上传：

首先templates下新建upload.html ，前端上传文件模版页面
```python
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>文件上传</title>
</head>
<body>
<form action="/upload" enctype="multipart/form-data" method="post">
	{% csrf_token %}
	<input type="file" name="myfile"><br><br>
	<input type="submit" value="上传文件">
</form>
</body>
</html>
```

views.py里定义to_upload和upload两个方法，分别是跳转文件页面，和文件上传处理
```python
def to_upload(request):
	"""
	跳转文件上传页面
	:param request:
	:return:
	"""
	return render(request, 'upload.html')

def upload(request):
	"""
	文件上传
	:param request:
	:return:
	"""
	# 获取上传的文件，如果没有文件，就默认为None
	myFile = request.FILES.get("myfile", None)
	if myFile:
	# 打开特定的文件进行二进制的写操作
	f = open(os.path.join("D:\\myFile", myFile.name), "wb+")
	# 分块写入文件
	for chunk in myFile.chunks():
	f.write(chunk)
	f.close()
	return HttpResponse("文件上传成功！")
	else:
	return HttpResponse("没发现文件！")
```


最后urls.py里，定义下映射：
path('toUpload/', helloWorld.views.to_upload),
path('upload', helloWorld.views.upload)

运行测试：浏览器输入 http://127.0.0.1:8000/toUpload/ ，进入文件上传页面：

文件对象myFile提供一下属性来获取文件信息：
- myFile.name:获取上传文件的文件名，包含文件后缀名。
- myFile.size:获取上传文件的文件大小。
- myFile.content_type:获取文件类型，通过后续名判断文件类型。

从文件对象myFile获取文件内容，Django提供了以下读取方式，每种方式说明如下。
- myFile.read():从文件对象里读取整个文件上传的数据，这个方法只适合小文件。
- myFile.chunks():按流式响应方式读取文件，在for 循环中进行迭代，将大文件分块写入服务器所指定的保存位置。
- myFile.multiple_chunks():判断文件对象的文件大小,返回True或者False,当文件大于2.5MB（默认值为2.5MB）时，该方法返回True，否则返回False。因此，可以根据该方法来选择选用read方法读取还是采用chunks方法。

![[05_视图View/images/Pasted image 20240619162604.png]]



# 9 文件上传2

## 9.1 前端HTML代码实现


文件上传是网站开发中非常常见的功能。这里详细讲述如何在Django 中实现文件的上传功能。

1. 在前端中，我们需要填入一个form 标签，然后在这个form 标签中指定 enctype="multipart/form-data" ，不然就不能上传文件。
2. 在form 标签中添加一个input 标签，然后指定input 标签的name ，以及type="file" 。

以上两步的示例代码如下
```python
<form action="" method="post" enctype="multipart/form-data">
    <input type="file" name="myfile">
</form>
```



## 9.2 后端的代码实现

后端的主要工作是接收文件。然后存储文件。接收文件的方式跟接收POST 的方式是一样的，只不过是通过FILES 来实现

```python
def save_file(file):
    with open('somefile.txt','wb') as fp:
        for chunk in file.chunks():
            fp.write(chunk)

def index(request):
    if request.method == 'GET':
        form = MyForm()
        return render(request,'index.html',{'form':form})
    else:
        myfile = request.FILES.get('myfile')
        save_file(myfile)
        return HttpResponse('success')
```

以上代码通过request.FILES 接收到文件后，再写入到指定的地方。这样就可以完成一个文件的上传功能了。


## 9.3 使用模型来处理上传的文件

在定义模型的时候，我们可以给存储文件的字段指定为FileField, 这个Field 可以传递一个 `upload_to` 参数，用来指定上传上来的文件保存到哪里。比如我们让他保存到项目的files 文件夹下


```python
# models.py
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    thumbnail = models.FileField(upload_to="files")  # 使用upload_to 给出要上传的地址 

# views.py
def index(request):
    if request.method == 'GET':
        return render(request,'index.html')
    else:
        title = request.POST.get('title')
        content = request.POST.get('content')
        thumbnail = request.FILES.get('thumbnail')
        article = Article(title=title, content=content, thumbnail=thumbnail)
        article.save()
        return HttpResponse('success')
```

调用完article.save() 方法，就会把文件保存到files 下面，并且会将这个文件的路径存储到数据库中。



## 9.4 指定MEDIA_ROOT和MEDIA_URL


以上我们是使用了upload_to 来指定上传的文件的目录。我们也可以指定MEDIA_ROOT ，就不需要在FielField 中指定upload_to ，他会自动的将文件上传到MEDIA_ROOT 的目录下

```python
MEDIA_ROOT = os.path.join(BASE_DIR,'media')
MEDIA_URL = '/media/'
```

然后我们可以在urls.py 中添加MEDIA_ROOT 目录下的访问路径。示例代码如下：

```python
from django.urls import path
from front import views
from django.conf.urls.static import static
from django.conf import settings

urlpatterns = [
    path('', views.index),
] + static(settings.MEDIA_URL,document_root=settings.MEDIA_ROOT)
```


如果我们同时指定MEDIA_ROOT 和upload_to ，那么会将文件上传到MEDIA_ROOT 下的upload_to 文件夹中。

```python 
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    thumbnail = models.FileField(upload_to="%Y/%m/%d/")
```

## 9.5 限制上传的文件拓展名


如果想要限制上传的文件的拓展名，那么我们就需要用到表单来进行限制。我们可以使用普通的Form 表单，也可以使用ModelForm ，直接从模型中读取字段。


```python
# models.py
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    thumbnial = models.FileField(upload_to='%Y/%m/%d/',validators=
[validators.FileExtensionValidator(['txt','pdf'])])

# forms.py
class ArticleForm(forms.ModelForm):
    class Meta:
        model = Article
        fields = "__all__"
```


## 9.6 上传图片 

上传图片跟上传普通文件是一样的。只不过是上传图片的时候Django 会判断上传的文件是否是图片的格式（除了判断后缀名，还会判断是否是可用的图片）。如果不是，那么就会验证失败。我们首先先来定义一个包含ImageField 的模型。

```
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    thumbnail = models.ImageField(upload_to="%Y/%m/%d/")
```


因为要验证是否是合格的图片，因此我们还需要用一个表单来进行验证。表单我们直接就使用ModelForm 就可以了

```
class MyForm(forms.ModelForm):
    class Meta:
        model = Article
        fields = "__all__"
```

注意：使用ImageField，必须要先安装Pillow库：pip install pillow



# 10 生成CSV文件

有时候我们做的网站，需要将一些数据，生成有一个CSV 文件给浏览器，并且是作为附件的形式下载下来。以下将讲解如何生成CSV 文件。

> 使用HttpResponse 来将csv 文件返回回去


## 10.1 生成小的CSV文件

这里将用一个生成小的CSV 文件为例，来把生成CSV 文件的技术要点讲到位。我们用Python 内置的csv 模块来处理csv 文件，并且使用HttpResponse 来将csv 文件返回回去。

```
import csv
from django.http import HttpResponse

def csv_view(request):
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="somefilename.csv"'
    writer = csv.writer(response)
    writer.writerow(['username', 'age', 'height', 'weight'])
    writer.writerow(['zhiliao', '18', '180', '110'])
    
    return response
```

这里再来对每个部分的代码进行解释：
1. 我们在初始化HttpResponse 的时候，指定了Content-Type 为text/csv ，这将告诉浏览器，这是一个csv 格式的文件而不是一个HTML 格式的文件，如果用默认值，默认值就是html ，那么浏览器将把csv 格式的文件按照html 格式输出，这肯定不是我们想要的。
2. 第二个我们还在response 中添加一个Content-Disposition 头，这个东西是用来告诉浏览器该如何处理这个文件，我们给这个头的值设置为attachment; ，那么浏览器将不会对这个文件进行显示，而是作为附件的形式下载，第二个filename="somefilename.csv" 是用来指定这个csv 文件的名字。
3. 我们使用csv 模块的writer 方法，将相应的数据写入到response 中。


## 10.2 将csv文件定义成模板

我们还可以将csv 格式的文件定义成模板，然后使用Django 内置的模板系统，并给这个模板传入一个Context 对象，这样模板系统就会根据传入的Context 对象，生成具体的csv 文件。

模版文件
```python
{% for row in data %}"{{ row.0|addslashes }}", "{{ row.1|addslashes }}", "{{row.2|addslashes }}", "{{ row.3|addslashes }}", "{{ row.4|addslashes }}"
{% endfor %}
```


视图函数 
```
from django.http import HttpResponse
from django.template import loader, Context

def some_view(request):
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="somefilename.csv"'
    
    csv_data = (
        ('First row', 'Foo', 'Bar', 'Baz'),
        ('Second row', 'A', 'B', 'C', '"Testing"', "Here's a quote"),
    )
    
    t = loader.get_template('my_template_name.txt')
    response.write(t.render({"data": csv_data}))
    
    return response
```



## 10.3 生成大的CSV文件

以上的例子是生成的一个小的csv 文件，如果想要生成大型的csv 文件，那么以上方式将有可能会发生超时的情况（服务器要生成一个大型csv文件，需要的时间可能会超过浏览器默认的超时时间）。这时候我们可以借助另外一个类，叫做StreamingHttpResponse 对象，这个对象是将响应的数据作为一个流返回给客户端，而不是作为一个整体返回。


```python
class Echo:
"""
定义一个可以执行写操作的类，以后调用csv.writer的时候，就会执行这个方法
"""
    def write(self, value):
        return value
        
def large_csv(request):
    rows = (["Row {}".format(idx), str(idx)] for idx in range(655360))
    pseudo_buffer = Echo()
    writer = csv.writer(pseudo_buffer)

    response = StreamingHttpResponse((writer.writerow(row) for row in
rows),content_type="text/csv")

    response['Content-Disposition'] = 'attachment; filename="somefilename.csv"'
    
    return response
```


这里我们构建了一个非常大的数据集rows ，并且将其变成一个迭代器。然后因为 StreamingHttpResponse 的第一个参数只能是一个生成器，因此我们使用圆括号 (writer.writerow(row) for row in rows) ，并且因为我们要写的文件是csv 格式的文件，因此需
要调用writer.writerow将row变成一个csv 格式的字符串。

而调用writer.writerow又需要一个中间的容器，因此这里我们定义了一个非常简单的类Echo ，这个类只实现一个write 方法，以后在执行 csv.writer(pseudo_buffer) 的时候，就会调用Echo.writer 方法。

注意： StreamingHttpResponse 会启动一个进程来和客户端保持长连接，所以会很消耗资源。所以如果不是特殊要求，尽量少用这种方法

## 10.4 关于StreamingHttpResponse

这个类是专门用来处理流数据的。使得在处理一些大型文件的时候，不会因为服务器处理时间过长而到时连接超时。这个类不是继承自HttpResponse ，并且跟HttpResponse 对比有以下几点区别：
1. 这个类没有属性content ，相反是streaming_content 。
2. 这个类的streaming_content 必须是一个可以迭代的对象。
3. 这个类没有write 方法，如果给这个类的对象写入数据将会报错。
注意： StreamingHttpResponse 会启动一个进程来和客户端保持长连接，所以会很消耗资源。所以如果不是特殊要求，尽量少用这种方法



