
# 1 视图

视图一般都写在app 的views.py 中。并且视图的第一个参数永远都是request （一个 HttpRequest）对象。这个对象存储了请求过来的所有信息，包括携带的参数以及一些头部信息等。在视图中，一般是完成逻辑相关的操作。
比如这个请求是添加一篇博客，那么可以通过request来接收到这些数据，然后存储到数据库中，最后再把执行的结果返回给浏览器。视图函数的返回结果必须是 HttpResponseBase 对象或者子类的对象。

示例代码如下：

```
from django.http import HttpResponse
def book_list(request):
return HttpResponse("书籍列表！")
```

视图可以是函数，也可以是类，我们先学习函数视图，后面再学习类视图。


# 2 MTV模型
视图(Views）是 Django的 MTV架构模式的V部分，主要负责处理用户请求和生成相应的响应内容,然后
在页面或其他类型文档中显示。
Django的MTV分别代表：
Model(模型)：业务对象与数据库的对象(ORM)
Template(模版)：负责如何把页面展示给用户
View(视图)：负责业务逻辑，并在适当的时候调用Model和Template

![[05_视图View/images/Pasted image 20240619145630.png]]


# 3 Django5设置视图响应状态

客户端请求后端服务，在view.py视图层方法最终return 返回视图响应。Python内置提供了响应类型，
来实现不同的返回不同的http状态码；


响应类型   解释说明
HttpResponse('Hello world'") 状态码200，请求已成功被服务器接收
HttpResponseRedirect('/') 状态码302，重定向首页地址
HttpResponsePermanentRedirect('/') 状态码301，永久重定向首页地址
HttpResponseBadRequest("'400') 状态码400，访问的页面不存在或请求错误
HttpResponseNotFound('404") 状态码404，网页不存在或网页的URL失效
HttpResponseForbidden('403') 状态码403，没有访问权限
HttpResponseNotAllowed('405') 状态码405，不允许使用该请求方式
HttpResponseServerError('500'") 状态码500，服务器内容错误
JsonResponse( {'foo' : 'bar'}) 默认状态码200，响应内容为JSON数据
StreamingHttpResponse() 默认状态码200，响应内容以流式输出


举例一：HttpResponse
修改helloWorld的views.py的index函数：
```
def index(request):
	html = "<font color='red'>学Python，上www.python222.com</font>"
	return HttpResponse(html, status=200)
```
![[05_视图View/images/Pasted image 20240619145826.png]]
请求测试，状态码200，返回网页信息。status=200不写的话默认也是200.



举例二：HttpResponseNotFound 404
```
def index(request):
	return HttpResponseNotFound()
```
![[05_视图View/images/Pasted image 20240619145903.png]]
请求测试，状态码404。


举例三：JsonResponse 响应json数据
```
def index(request):
	return JsonResponse({'foo': 'bar'})
```
![[05_视图View/images/Pasted image 20240619145927.png]]
请求测试，状态码200，返回json格式数据。


## 3.1 HttpResponse: 渲染网页 

我们第一个实例用到的是HttpResponse，简单网页我们直接可以响应到页面，但是假如是复杂网页，就会增加视图函数的代码量。所以我们引入模版，通过django提供的render方法渲染数据到模版，然后再响应到页面。

```
def index(request):
	return render(request, 'index.html')
```

这个是我们前面的的HelloWorld代码，我们ctrl点进去render方法，看下源码：
![[05_视图View/images/Pasted image 20240619150138.png]]
经过模版渲染后得到content网页内容，依然返回的是HttpResponse对象。

render方法定义：
```
def render(
	request, template_name, context=None, content_type=None, status=None,
using=None
):
```

request和template_name是必须的参数。其他参数可选。
- request:浏览器向服务器发送的请求对象，包含用户信息、请求内容和请求方式等。
- template_name:设置模板文件名，用于生成网页内容。
- context:对模板上下文（模板变量）赋值，以字典格式表示，默认情况下是一个空字典。
- content_type:响应内容的数据格式，一般情况下使用默认值即可。
- status: HTTP状态码，默认为200.
- using:设置模板引擎，用于解析模板文件，生成网页内容。


我们再写一个带字典参数的render渲染模版实例：
views.py改写下：
```
def index(request):
	content_value = {"msg": '学Python，上www.python222.com'}
	return render(request, 'index.html', context=content_value)
```

模版代码改写下，模版里取值语法 {{ 字典的key值 }}
```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
</head>
<body>
模版取值： {{ msg }}
</body>
</html>
```

# 4 HttpResponse对象

Django服务器接收到客户端发送过来的请求后，会将提交上来的这些数据封装成一个HttpRequest 对象传给视图函数。那么视图函数在处理完相关的逻辑后，也需要返回一个响应给浏览器。而这个响应，我们必须返回HttpResponseBase 或者他的子类的对象。而HttpResponse 则是HttpResponseBase 用得最多的子类。\

那么接下来就来介绍一下HttpResponse 及其子类

## 4.1 常用属性：
1. content：返回的内容。
2. status_code：返回的HTTP响应状态码。
3. content_type：返回的数据的MIME类型，默认为text/html 。浏览器会根据这个属性，来显示数据。如果是text/html ，那么就会解析这个字符串，如果text/plain ，那么就会显示一个纯文本。常用的Content-Type 如下：
    1. text/html（默认的，html文件）
    2. text/plain（纯文本）
    3. text/css（css文件）
    4. text/javascript（js文件）
    5. multipart/form-data（文件提交）
    6. application/json（json传输）
    7. application/xml（xml文件）
4. 设置请求头： response['X-Access-Token'] = 'xxxx' 。


## 4.2 常用方法：
1. set_cookie：用来设置cookie 信息。后面讲到授权的时候会着重讲到。
2. delete_cookie：用来删除cookie 信息。
3. write： HttpResponse 是一个类似于文件的对象，可以用来写入数据到数据体（content）中。


## 4.3 JsonResponse类：

用来对象 dump 成json 字符串，然后返回将json 字符串封装成Response 对象返回给浏览器。并且他的Content-Type 是application/json 。示例代码如下
```
from django.http import JsonResponse

def index(request):
    return JsonResponse({"username":"zhiliao","age":18})
```


默认情况下JsonResponse 只能对字典进行dump ，如果想要对非字典的数据进行dump ，那么需要给JsonResponse 传递一个safe=False 参数
```
from django.http import JsonResponse

def index(request):
    persons = ['张三','李四','王五']
    return HttpResponse(persons)
```

以上代码会报错，应该在使用HttpResponse 的时候，传入一个safe=False 参数，示例代码如下：
`return HttpResponse(persons,safe=False)`


# 5 Http请求&HttpRequest请求类

超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。

当在浏览器上访问某个网址时，其实质是向网站发送一个HTTP请求，HTTP请求分为8种请求方式，每种请求方式的说明如下：

请求方式 说明
OPTIONS 返回服务器针对特定资源所支持的请求方法
GET 向特定资源发出请求（访问网页）
POST 向指定资源提交数据处理请求（提交表单、上传文件)
PUT 向指定资源位置上传数据内容
DELETE 请求服务器删除request-URL所标示的资源
HEAD 与GET请求类似，返回的响应中没有具体内容，用于获取报头
TRACE 回复和显示服务器收到的请求，用于测试和诊断
CONNECT HTTP/1.1协议中能够将连接改为管道方式的代理服务器


在上述的HTTP请求方式里，最基本的是GET请求和POST 请求，网站开发者关心的也只有GET请求和 POST请求。GET请求和 POST请求是可以设置请求参数的，两者的设置方式如下:
- GET请求的请求参数是在路由地址后添加“?”和参数内容，参数内容以key=value 形式表示，等号前面的是参数名，后面的是参数值，如果涉及多个参数，每个参数之间就使用“&”隔开，如127.0.0.1:8000/?name=python222&pw=123456。
- POST请求的请求参数一般以表单的形式传递，常见的表单使用HTML的 form标签，并且form标签的method 属性设为POST.

再Django5中，Http请求信息都被封装到了HttpRequest类中。

HttpRequest类的常用属性如下：
- COOKIE:获取客户端（浏览器）的Cookie信息，以字典形式表示，并且键值对都是字符串类型。
- FILES: django.http.request.QueryDict对象，包含所有的文件上传信息。
- GET:获取GET请求的请求参数，它是django.http.request.QueryDict对象，操作起来类似于字典。
- POST:获取POST请求的请求参数，它是django.http.request.QueryDict对象，操作起来类似于字典
- META:获取客户端（浏览器）的请求头信息，以字典形式存储。
- method:获取当前请求的请求方式(GET请求或POST请求).
- path:获取当前请求的路由地址。
- session:一个类似于字典的对象，用来操作服务器的会话信息，可临时存放用户信息。
- user:当 Django启用AuthenticationMiddleware中间件时才可用。它的值是内置数据模型User的对象，表示当前登录的用户。如果用户当前没有登录，那么user将设为 django.contrib.auth.models.AnonymousUser的一个实例。

HttpRequest类常用方法如下：
- is_secure():是否是采用HTTPS协议。
- get_host():获取服务器的域名。如果在访问的时候设有端口，就会加上端口号，如 127.0.0.1:8000。
- get_full path():返回路由地址。如果该请求为GET请求并且设有请求参数，返回路由地址就会将请求参数返回，如/?name=python222&pw=123456。


## 5.1 例子

先views.py里定义两个方法，分别测试get和post：

```python
def get_test(request):
	"""
	get请求测试
	:param request:
	:return:
	"""
	print(request.method) # 请求方式
	# 常用属性
	print(request.content_type)
	print(request.content_params)
	print(request.COOKIES)
	print(request.scheme)
	# 常用方法
	print(request.is_secure())
	print(request.get_host())
	print(request.get_full_path())
	print(request.GET.get("name"))
	print(request.GET.get("pwd"))
	print(request.GET.get("aaa", "666"))
	return HttpResponse("http get ok")


def post_test(request):
	"""
	post请求测试
	:param request:
	:return:
	"""
	print(request.method) # 请求方式
	
	print(request.POST.get("name"))
	print(request.POST.get("pwd"))
	print(request.POST.get("aaa", "666"))
	return HttpResponse("http post ok")
```

urls.py里定义下映射：
```
path('get', helloWorld.views.get_test),
path('post', helloWorld.views.post_test)
```

模版里新建http.html，这里我们不能用静态页面，需要一个csrf安全机制token 需要后端server来提
供，所以只能用模版

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
</head>
<body>
<a href="/get?name=python222&pwd=123456" target="_blank">http get请求测试</a><br>
<br>
<form action="/post" method="post">
	{% csrf_token %}
	name:<input type="text" name="name"><br>
	pwd:<input type="text" name="pwd">
	<input type="submit" value="提交"></input>
</form>
</body>
</html>
```


请求index跳转到http.html
```
def index(request):
	return render(request, 'http.html')
```

浏览器输入 http://127.0.0.1:8000/index/ 测试：
![[05_视图View/images/Pasted image 20240619154517.png]]

点击get链接地址：
后台输出：
```
GET
text/plain
{}
{'csrftoken': 'GDgfE2kvXwRYS6WMejaYNE9ij9KPodHi'}
http
False
127.0.0.1:8000
/get?name=python222&pwd=123456
python222
123456
666
请求处理完毕，将返回到页面
[20/Feb/2024 17:09:52] "GET /get?name=python222&pwd=123456 HTTP/1.1" 200 11
```

再post表单测试：
后台输出：
```
POST
python222
123456
666
```


# 6 render_to_response

wiki/views.py

```Python
from .models import Wiki
from django.template import loader, Context
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import render_to_response
from django.views.decorators.csrf import csrf_exempt

def index(request, pagename=""):
    """显示正常页面，对页面的文字做特殊的链接处理"""
    if pagename:
        #查找是否已经存在页面
#        pages = Wiki.objects.get_list(pagename__exact=pagename)
        pages = Wiki.objects.filter(pagename=pagename)
        if pages:
            #存在则调用页面模板进行显示
            return process('wiki/page.html', pages[0])
        else:
            #不存在则进入编辑画面
            return render_to_response('wiki/edit.html', {'pagename':pagename})

    else:
#        page = Wiki.objects.get_object(pagename__exact='FrontPage')
        page = Wiki.objects.get(pagename='FrontPage')
        return process('wiki/page.html', page)

@csrf_exempt
def edit(request, pagename):
    """显示编辑存在页面"""
#    page = Wiki.objects.get_object(pagename__exact=pagename)
    page = Wiki.objects.get(pagename=pagename)
    return render_to_response('wiki/edit.html', {'pagename':pagename, 'content':page.content})

@csrf_exempt
def save(request, pagename):
    """保存页面内容，老页面进行内容替换，新页面生成新记录"""
    content = request.POST['content']
#    pages = Wiki.objects.get_list(pagename__exact=pagename)
    pages = Wiki.objects.filter(pagename=pagename)
    if pages:
        pages[0].content = content
        pages[0].save()
    else:
        page = Wiki(pagename=pagename, content=content)
        page.save()
    return HttpResponseRedirect("/%s" % pagename)

import re

r = re.compile(r'\b(([A-Z]+[a-z]+){2,})\b')
def process(template, page):
    """处理页面链接，并且将回车符转为<br>"""
    t = loader.get_template(template)
    content = r.sub(r'<a href="/\1">\1</a>', page.content)
    content = re.sub(r'[\n\r]+', '<br>', content)
    c = {'pagename':page.pagename, 'content':content}
    return HttpResponse(t.render(c))
```



# 7 Django5设置重定向响应


Django重定向我们前面讲过一种urls.py里使用RedirectView实现
```
path('redirectTo', RedirectView.as_view(url="index/"))
```

这种方便书写简单，但是不灵活，我们实际开发，为了能否实现业务上的判断，来进行业务重定向跳转，还是需要用redirect方法。
重定向的状态码分为301和302，前者是永久性跳转的，后者是临时跳转的，两者的区别在于搜索引擎的网页抓取。

重定向分为永久性重定向和暂时性重定向，在页面上体现的操作就是浏览器会从一个页面自动跳转到另外一个页面。比如用户访问了一个需要权限的页面，但是该用户当前并没有登录，因此我们应该给他重定向到登录页面。

永久性重定向：
301重定向是永久的重定向，搜索引擎在抓取新内容的同时会将旧的网址替换为重定向之后的网址。
http的状态码是301，多用于旧网址被废弃了要转到一个新的网址确保用户的访问，最经典的就是京东网站，你输入www.jingdong.com的时候，会被重定向到www.jd.com，因为jingdong.com这个网址已经被废弃了，被改成jd.com，所以这种情况下应该用永久重定向。

暂时性重定向：
http的状态码是302，表示页面的暂时性跳转。比如访问一个需要权限的网址，如果当前用户没有登录，应该重定向到登录页面，这种情况下，应该用暂时性重定向。在Django 中，重定向是使用`redirect(to, *args, permanent=False, **kwargs) `来实现的。to 是一个url ， permanent 代表的是这个重定向是否是一个永久的重定向，默认是False 。
302跳转是暂时的跳转，搜索引擎会抓取新内容而保留旧的网址。因为服务器返回302代码，所以搜索引擎认为新的网址只是暂时的。


Django内置提供了重定向类HttpResponseRedirect和HttpResponsePermanentRedirect分别代表
HTTP状态码302和301

![[05_视图View/images/Pasted image 20240619152113.png]]

## 7.1 例子 

### 7.1.1 

关于重定向的使用，请看以下例子：

```python
from django.shortcuts import reverse,redirect
def profile(request):
    if request.GET.get("username"):
        return HttpResponse("%s，欢迎来到个人中心页面！")
    else:
        return redirect(reverse("user:login"))
```


### 7.1.2 

我们static下面新建一个新页面new.html
![[05_视图View/images/Pasted image 20240619152455.png]]

改写helleWorld里得index方法：

```
def index(request):
	return redirect("/static/new.html")
```

我们测试下：请求 http://127.0.0.1:8000/index/ 302跳转到了new.html页面 （最好用谷歌浏览器得无痕浏览，这样没有缓存干扰测试）

![[05_视图View/images/Pasted image 20240619152535.png]]


我们加上 permanent=True 参数；
```
def index(request):
	return redirect("/static/new.html", permanent=True)
```


再测试下，就变成301永久跳转了。

![[05_视图View/images/Pasted image 20240619152609.png]]


## 7.2 redirect方法的源码

我们点进去看下redirect方法的源码实现：

```
def redirect(to, *args, permanent=False, **kwargs):
"""
Return an HttpResponseRedirect to the appropriate URL for the arguments
passed.
The arguments could be:
* A model: the model's `get_absolute_url()` function will be called.
* A view name, possibly with arguments: `urls.reverse()` will be used
to reverse-resolve the name.

* A URL, which will be used as-is for the redirect location.
Issues a temporary redirect by default; pass permanent=True to issue a
permanent redirect.
"""

redirect_class = (
	HttpResponsePermanentRedirect if permanent else HttpResponseRedirect
)
return redirect_class(resolve_url(to, *args, **kwargs))
```

第一个跳转参数支持模型，视图路由名称，还有最常用得url地址；第二个参数就是是否永久跳转，默认
Flase；
redirect_class通过permanent判断，true返回HttpResponsePermanentRedirect，false返回
HttpResponseRedirect;

