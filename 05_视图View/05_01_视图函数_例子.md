

# 1 Django5二进制文件下载

响应内容除了返回网页信息外，还可以实现文件下载功能，是网站常用的功能之一。

Django提供三种方式实现文件下载功能，分别是HttpResponse、StreamingHttpResponse和FileResponse,三者的说明如下:
- HttpResponse是所有响应过程的核心类，它的底层功能类是HttpResponseBase。
- StreamingHttpResponse是在 HttpResponseBase的基础上进行继承与重写的，它实现流式响应输出（流式响应输出是使用Python的迭代器将数据进行分段处理并传输的)，适用于大规模数据响应和文件传输响应。
- FileResponse是在StreamingHttpResponse 的基础上进行继承与重写的，它实现文件的流式响应输出，只适用于文件传输响应。



## 1.1 例子 

我们准备一个文件，这里我们用一个exe二进制文件。放D盘根目录。


views.py里写方法实现方法：
```python
# 定义文件路径
file_path = "D:\\360zip_setup.exe"

def download_file1(request):
	file = open(file_path, 'rb') # 打开文件
	response = HttpResponse(file) # 创建HttpResponse对象
	response['Content_Type'] = 'application/octet-stream'
	response['Content-Disposition'] = 'attachment;filename=file1.exe'
	return response

def download_file2(request):
	file = open(file_path, 'rb') # 打开文件
	response = StreamingHttpResponse(file) # 创建StreamingHttpResponse对象
	response['Content_Type'] = 'application/octet-stream'
	response['Content-Disposition'] = 'attachment;filename=file2.exe'
	return response


def download_file3(request):
	file = open(file_path, 'rb') # 打开文件
	response = FileResponse(file) # 创建FileResponse对象
	response['Content_Type'] = 'application/octet-stream'
	response['Content-Disposition'] = 'attachment;filename=file3.exe'
	return response
```

urls.py里定义下映射：
```
path('download1', helloWorld.views.download_file1),
path('download2', helloWorld.views.download_file2),
path('download3', helloWorld.views.download_file3)
```


为了方便测试，我们static目录下新建一个download.html静态文件：
```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>下载测试</title>
</head>
<body>
<a href="/download1">下载测试一：HttpResponse</a><br>
<a href="/download2">下载测试二：StreamingHttpResponse</a><br>
<a href="/download3">下载测试三：FileResponse</a>
</body>
</html>
```

页面输入： http://127.0.0.1:8000/static/download.html 测试：
![[05_视图View/images/Pasted image 20240619153316.png]]


# 2 Django5文件上传


### 2.1.1 例子1

文件上传功能是网站开发或者业务系统常见的功能之一，比如上传图片（用户头像或文章配图）和导入文件（压缩包，视频，音乐)。无论上传的文件是什么格式的，其上传原理都是将文件以二进制的数据格式读取并写入网站或者业务系统指定的目录里。

我们通过一个实例来深入体验学习下文件上传：

首先templates下新建upload.html ，前端上传文件模版页面
```python
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>文件上传</title>
</head>
<body>
<form action="/upload" enctype="multipart/form-data" method="post">
	{% csrf_token %}
	<input type="file" name="myfile"><br><br>
	<input type="submit" value="上传文件">
</form>
</body>
</html>
```

views.py里定义to_upload和upload两个方法，分别是跳转文件页面，和文件上传处理
```python
def to_upload(request):
	"""
	跳转文件上传页面
	:param request:
	:return:
	"""
	return render(request, 'upload.html')

def upload(request):
	"""
	文件上传
	:param request:
	:return:
	"""
	# 获取上传的文件，如果没有文件，就默认为None
	myFile = request.FILES.get("myfile", None)
	if myFile:
	# 打开特定的文件进行二进制的写操作
	f = open(os.path.join("D:\\myFile", myFile.name), "wb+")
	# 分块写入文件
	for chunk in myFile.chunks():
	f.write(chunk)
	f.close()
	return HttpResponse("文件上传成功！")
	else:
	return HttpResponse("没发现文件！")
```


最后urls.py里，定义下映射：
path('toUpload/', helloWorld.views.to_upload),
path('upload', helloWorld.views.upload)

运行测试：浏览器输入 http://127.0.0.1:8000/toUpload/ ，进入文件上传页面：

文件对象myFile提供一下属性来获取文件信息：
- myFile.name:获取上传文件的文件名，包含文件后缀名。
- myFile.size:获取上传文件的文件大小。
- myFile.content_type:获取文件类型，通过后续名判断文件类型。

从文件对象myFile获取文件内容，Django提供了以下读取方式，每种方式说明如下。
- myFile.read():从文件对象里读取整个文件上传的数据，这个方法只适合小文件。
- myFile.chunks():按流式响应方式读取文件，在for 循环中进行迭代，将大文件分块写入服务器所指定的保存位置。
- myFile.multiple_chunks():判断文件对象的文件大小,返回True或者False,当文件大于2.5MB（默认值为2.5MB）时，该方法返回True，否则返回False。因此，可以根据该方法来选择选用read方法读取还是采用chunks方法。

![[05_视图View/images/Pasted image 20240619162604.png]]



## 2.2 例子22

### 2.2.1 前端HTML代码实现


文件上传是网站开发中非常常见的功能。这里详细讲述如何在Django 中实现文件的上传功能。

1. 在前端中，我们需要填入一个form 标签，然后在这个form 标签中指定 enctype="multipart/form-data" ，不然就不能上传文件。
2. 在form 标签中添加一个input 标签，然后指定input 标签的name ，以及type="file" 。

以上两步的示例代码如下
```python
<form action="" method="post" enctype="multipart/form-data">
    <input type="file" name="myfile">
</form>
```



### 2.2.2 后端的代码实现

后端的主要工作是接收文件。然后存储文件。接收文件的方式跟接收POST 的方式是一样的，只不过是通过FILES 来实现

```python
def save_file(file):
    with open('somefile.txt','wb') as fp:
        for chunk in file.chunks():
            fp.write(chunk)

def index(request):
    if request.method == 'GET':
        form = MyForm()
        return render(request,'index.html',{'form':form})
    else:
        myfile = request.FILES.get('myfile')
        save_file(myfile)
        return HttpResponse('success')
```

以上代码通过request.FILES 接收到文件后，再写入到指定的地方。这样就可以完成一个文件的上传功能了。


### 2.2.3 使用模型来处理上传的文件

在定义模型的时候，我们可以给存储文件的字段指定为FileField, 这个Field 可以传递一个 `upload_to` 参数，用来指定上传上来的文件保存到哪里。比如我们让他保存到项目的files 文件夹下


```python
# models.py
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    thumbnail = models.FileField(upload_to="files")  # 使用upload_to 给出要上传的地址 

# views.py
def index(request):
    if request.method == 'GET':
        return render(request,'index.html')
    else:
        title = request.POST.get('title')
        content = request.POST.get('content')
        thumbnail = request.FILES.get('thumbnail')
        article = Article(title=title, content=content, thumbnail=thumbnail)
        article.save()
        return HttpResponse('success')
```

调用完article.save() 方法，就会把文件保存到files 下面，并且会将这个文件的路径存储到数据库中。



### 2.2.4 指定MEDIA_ROOT和MEDIA_URL


以上我们是使用了upload_to 来指定上传的文件的目录。我们也可以指定MEDIA_ROOT ，就不需要在FielField 中指定upload_to ，他会自动的将文件上传到MEDIA_ROOT 的目录下

```python
MEDIA_ROOT = os.path.join(BASE_DIR,'media')
MEDIA_URL = '/media/'
```

然后我们可以在urls.py 中添加MEDIA_ROOT 目录下的访问路径。示例代码如下：

```python
from django.urls import path
from front import views
from django.conf.urls.static import static
from django.conf import settings

urlpatterns = [
    path('', views.index),
] + static(settings.MEDIA_URL,document_root=settings.MEDIA_ROOT)
```


如果我们同时指定MEDIA_ROOT 和upload_to ，那么会将文件上传到MEDIA_ROOT 下的upload_to 文件夹中。

```python 
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    thumbnail = models.FileField(upload_to="%Y/%m/%d/")
```

### 2.2.5 限制上传的文件拓展名


如果想要限制上传的文件的拓展名，那么我们就需要用到表单来进行限制。我们可以使用普通的Form 表单，也可以使用ModelForm ，直接从模型中读取字段。


```python
# models.py
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    thumbnial = models.FileField(upload_to='%Y/%m/%d/',validators=
[validators.FileExtensionValidator(['txt','pdf'])])

# forms.py
class ArticleForm(forms.ModelForm):
    class Meta:
        model = Article
        fields = "__all__"
```


### 2.2.6 上传图片 

上传图片跟上传普通文件是一样的。只不过是上传图片的时候Django 会判断上传的文件是否是图片的格式（除了判断后缀名，还会判断是否是可用的图片）。如果不是，那么就会验证失败。我们首先先来定义一个包含ImageField 的模型。

```
class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    thumbnail = models.ImageField(upload_to="%Y/%m/%d/")
```


因为要验证是否是合格的图片，因此我们还需要用一个表单来进行验证。表单我们直接就使用ModelForm 就可以了

```
class MyForm(forms.ModelForm):
    class Meta:
        model = Article
        fields = "__all__"
```

注意：使用ImageField，必须要先安装Pillow库：pip install pillow

# 3 csv文件上传和显示

## 3.1 引言

上一讲的确很长，但如果看代码你会发现，代码主要在 model 的调整中，`urls.py` 的工作不多，而连一行 view 的代码都没有写。是不是非常方便呢！

那么让我们来继续完善这个通讯录吧。

现在我想完成的是：

* 增加批量导入和导出功能

为什么要批量导入呢？因为一般情况下，我一定是已经有了一个通讯录文件(象以前我说过的Excel文件)，那么现在需要转到 web 上来，难道要我一条条全部手工录入吗？能不能上传文件，自动插入到数据库中去呢？那么就让我们实现一个文件上传的处理吧。

为了简化，我采用csv格式文本文件(这个文件在svn中有一个例子 `data.csv` ，不然就自行生成好了)。

```
abc,M,11,11,11,
bcd,M,11,11,11,
ass,M,11,11,11,
dfsdf,F,11,11,11,
sfas,F,11,11,11,
...
```

## 3.2 修改 address/templates/address/list.html

```html
<h1 id="title">通讯录</h1>
<hr>
<form enctype="multipart/form-data" method="POST" action="/address/upload/">
上传通讯录文件： <input type="file" name="file"/><br/>
<input type="submit" value="上传文件"/>
</form>
<table border="1">
<tr>
  <th>姓名</th>
  <th>性别</th>
  <th>电话</th>
  <th>手机</th>
  <th>房间</th>
</tr>
{% for person in address_list %}
<tr>
  <td>{{ person.name }}</td>
  <td>{{ person.gender }}</td>
  <td>{{ person.telphone }}</td>
  <td>{{ person.mobile }}</td>
  <td>{{ person.room }}</td>
</tr>
{% endfor %}
</table>
```

## 3.3 修改 address/views.py

```python
from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt
def upload(request):
    file_obj = request.FILES.get('file', None)
    if file_obj:
        import csv
        from io import StringIO
        try:
            csvfile = StringIO(file_obj.read().decode())
            reader = csv.reader(csvfile)
        except:
            return render_to_response('address/error.html',
                {'message':'你需要上传一个csv格式的文件！'})
        for row in reader:
            objs = Address.objects.filter(name=row[0])
            if not objs:
                obj = Address(name=row[0], gender=row[1],
                    telphone=row[2], mobile=row[3], room=row[4])
            else:
                obj = objs[0]
                obj.gender = row[1]
                obj.telphone = row[2]
                obj.mobile = row[3]
                obj.room = row[4]
            obj.save()

        return HttpResponseRedirect('/address/')
    else:
        return render_to_response('address/error.html',
            {'message':'你需要上传一个文件！'})
```

这里有一个 `upload()` 方法，它将使用 csv 模块来处理上传的 csv 文件。首先查找姓名是否存在于数据库中，如果不存在则创建新记录。如果存在则进行替换。如果没有指定文件直接上传，则报告一个错误。如果解析 csv 文件出错，则也报告一个错误。

报造错误使用了一个名为 error 的模板，我们马上要创建。

## 3.4 创建 address/templates/address/error.html

```html
<h2>出错</h2>
<p>{{ message }}</p>
<hr>
<p><a href="/address/">返回</a></p>
```

很简单。

## 3.5 修改 address/urls.py

```python
from django.conf.urls import url

from . import views

urlpatterns = [
    url(r'^$', views.IndexView.as_view(), name='index'),
    url(r'^upload/$', views.upload),
]
```

增加一个 upload 的 url 映射。

## 3.6 启动 server 测试

这样导入功能就做完了。那导出呢？很简单了，参考 csv 的例子去做就可以了。不过，并不全是这样，仍然有要修改的地方，比如 csv.html 模板，它因为写死了处理几个元素，因此需要改成一个循环处理。

## 3.7 修改 address/templates/address/csv.html

```python
{% for row in data %}{% for i in row %}"{{ i|addslashes }}",{% endfor %}
{% endfor %}
```

将原来固定个数的输出改为循环处理。

## 3.8 修改 address/templates/address/list.html

增加一个生成导出的 csv 文件的链接

```python
<h1 id="title">通讯录</h1>
<hr>
<form enctype="multipart/form-data" method="POST" action="/address/upload/">
上传通讯录文件： <input type="file" name="file"/><br/>
<input type="submit" value="上传文件"/>
</form>
<hr>
<p><a href="/address/output/">导出为csv格式文件</a></p>
<table border="1">
<tr>
  <th>姓名</th>
  <th>性别</th>
  <th>电话</th>
  <th>手机</th>
  <th>房间</th>
</tr>
{% for person in object_list %}
<tr>
  <td>{{ person.name }}</td>
  <td>{{ person.gender }}</td>
  <td>{{ person.telphone }}</td>
  <td>{{ person.mobile }}</td>
  <td>{{ person.room }}</td>
</tr>
{% endfor %}
</table>
```

## 3.9 修改 apps/address/views.py

```python
from django.http import HttpResponse
from django.template import loader, Context

def output(request):
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename=%s' % 'address.csv'
    t = loader.get_template('address/csv.html')
    objs = Address.objects.all()
    d = []
    for o in objs:
        d.append((o.name, o.gender, o.telphone, o.mobile, o.room))
    c = {'data': d,}
    response.write(t.render(c))
    return response
```

在开始处增加了对 `HttpResponse`, `loader`, `Context` 的导入。然后增加了用于输出处理的 `output()` 方法。

## 3.10 修改 address/urls.py

```python
from django.conf.urls import url

from . import views

urlpatterns = [
    url(r'^$', views.IndexView.as_view(), name='index'),
    url(r'^upload/$', views.upload),
    url(r'^output/$', views.output),
]
```

增加了对 output 方法的 url 映射。

## 3.11 启动 server 测试

# 4 生成CSV文件

有时候我们做的网站，需要将一些数据，生成有一个CSV 文件给浏览器，并且是作为附件的形式下载下来。以下将讲解如何生成CSV 文件。

> 使用HttpResponse 来将csv 文件返回回去


## 4.1 生成小的CSV文件

这里将用一个生成小的CSV 文件为例，来把生成CSV 文件的技术要点讲到位。我们用Python 内置的csv 模块来处理csv 文件，并且使用HttpResponse 来将csv 文件返回回去。

```
import csv
from django.http import HttpResponse

def csv_view(request):
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="somefilename.csv"'
    writer = csv.writer(response)
    writer.writerow(['username', 'age', 'height', 'weight'])
    writer.writerow(['zhiliao', '18', '180', '110'])
    
    return response
```

这里再来对每个部分的代码进行解释：
1. 我们在初始化HttpResponse 的时候，指定了Content-Type 为text/csv ，这将告诉浏览器，这是一个csv 格式的文件而不是一个HTML 格式的文件，如果用默认值，默认值就是html ，那么浏览器将把csv 格式的文件按照html 格式输出，这肯定不是我们想要的。
2. 第二个我们还在response 中添加一个Content-Disposition 头，这个东西是用来告诉浏览器该如何处理这个文件，我们给这个头的值设置为attachment; ，那么浏览器将不会对这个文件进行显示，而是作为附件的形式下载，第二个filename="somefilename.csv" 是用来指定这个csv 文件的名字。
3. 我们使用csv 模块的writer 方法，将相应的数据写入到response 中。


## 4.2 将csv文件定义成模板

我们还可以将csv 格式的文件定义成模板，然后使用Django 内置的模板系统，并给这个模板传入一个Context 对象，这样模板系统就会根据传入的Context 对象，生成具体的csv 文件。

模版文件
```python
{% for row in data %}"{{ row.0|addslashes }}", "{{ row.1|addslashes }}", "{{row.2|addslashes }}", "{{ row.3|addslashes }}", "{{ row.4|addslashes }}"
{% endfor %}
```


视图函数 
```
from django.http import HttpResponse
from django.template import loader, Context

def some_view(request):
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="somefilename.csv"'
    
    csv_data = (
        ('First row', 'Foo', 'Bar', 'Baz'),
        ('Second row', 'A', 'B', 'C', '"Testing"', "Here's a quote"),
    )
    
    t = loader.get_template('my_template_name.txt')
    response.write(t.render({"data": csv_data}))
    
    return response
```



## 4.3 生成大的CSV文件

以上的例子是生成的一个小的csv 文件，如果想要生成大型的csv 文件，那么以上方式将有可能会发生超时的情况（服务器要生成一个大型csv文件，需要的时间可能会超过浏览器默认的超时时间）。这时候我们可以借助另外一个类，叫做StreamingHttpResponse 对象，这个对象是将响应的数据作为一个流返回给客户端，而不是作为一个整体返回。


```python
class Echo:
"""
定义一个可以执行写操作的类，以后调用csv.writer的时候，就会执行这个方法
"""
    def write(self, value):
        return value
        
def large_csv(request):
    rows = (["Row {}".format(idx), str(idx)] for idx in range(655360))
    pseudo_buffer = Echo()
    writer = csv.writer(pseudo_buffer)

    response = StreamingHttpResponse((writer.writerow(row) for row in
rows),content_type="text/csv")

    response['Content-Disposition'] = 'attachment; filename="somefilename.csv"'
    
    return response
```


这里我们构建了一个非常大的数据集rows ，并且将其变成一个迭代器。然后因为 StreamingHttpResponse 的第一个参数只能是一个生成器，因此我们使用圆括号 (writer.writerow(row) for row in rows) ，并且因为我们要写的文件是csv 格式的文件，因此需
要调用writer.writerow将row变成一个csv 格式的字符串。

而调用writer.writerow又需要一个中间的容器，因此这里我们定义了一个非常简单的类Echo ，这个类只实现一个write 方法，以后在执行 csv.writer(pseudo_buffer) 的时候，就会调用Echo.writer 方法。

注意： StreamingHttpResponse 会启动一个进程来和客户端保持长连接，所以会很消耗资源。所以如果不是特殊要求，尽量少用这种方法

## 4.4 关于StreamingHttpResponse

这个类是专门用来处理流数据的。使得在处理一些大型文件的时候，不会因为服务器处理时间过长而到时连接超时。这个类不是继承自HttpResponse ，并且跟HttpResponse 对比有以下几点区别：
1. 这个类没有属性content ，相反是streaming_content 。
2. 这个类的streaming_content 必须是一个可以迭代的对象。
3. 这个类没有write 方法，如果给这个类的对象写入数据将会报错。
注意： StreamingHttpResponse 会启动一个进程来和客户端保持长连接，所以会很消耗资源。所以如果不是特殊要求，尽量少用这种方法





