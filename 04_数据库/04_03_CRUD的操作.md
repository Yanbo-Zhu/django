
在ORM 框架中，所有模型相关的操作，比如添加/删除等。其实都是映射到数据库中一条数据的操作。因此模型操作也就是数据库表中数据的操作


# 1 添加一个模型到数据库中

添加模型到数据库中。首先需要创建一个模型。创建模型的方式很简单，就跟创建普通的Python 对象是一摸一样的。在创建完模型之后，需要调用模型的save 方法，这样Django 会自动的将这个模型转换成sql 语句，然后存储到数据库中。示例代码如下：

```
class Book(models.Model):
    name = models.CharField(max_length=20,null=False)
    desc = models.CharField(max_length=100,name='description',db_column="description1")
    pub_date = models.DateTimeField(auto_now_add=True)

book = Book(name='三国演义',desc='三国英雄！')
book.save()
```

# 2 查找数据 

查找数据都是通过模型下的objects 对象来实现的。

## 2.1 查找所有数据：
要查找Book 这个模型对应的表下的所有数据。那么示例代码如下
`books = Book.objects.all()`

以上将返回Book模型下的所有数据

## 2.2 数据过滤

在查找数据的时候，有时候需要对一些数据进行过滤。那么这时候需要调用objects 的filter 方法。
实例代码如下：

```
books = Book.objects.filter(name='三国演义')
> [<Book:三国演义>]
> 
# 多个条件
books = Book.objects.filter(name='三国演义',desc='test')
```

调用filter ，会将所有满足条件的模型对象都返回。


## 2.3 获取单个对象 

使用filter 返回的是所有满足条件的结果集。有时候如果只需要返回第一个满足条件的对象。那么可以使用get 方法

```
book = Book.objects.get(name='三国演义')
> <Book:三国演义>
```

当然，如果没有找到满足条件的对象，那么就会抛出一个异常。而filter 在没有找到满足条件的数据的时候，是返回一个空的列表。

## 2.4 数据排序


在之前的例子中，数据都是无序的。如果你想在查找数据的时候使用某个字段来进行排序，那么可以使用order_by 方法来实现。

```
books = Book.objects.order_by("pub_date")
```

以上代码在提取所有书籍的数据的时候，将会使用pub_date 从`小到大`进行排序。

如果想要进行倒序排序，那么可以在pub_date 前面加一个负号。
`books = Book.objects.order_by("-pub_date")`


# 3 修改数据 

在查找到数据后，便可以进行修改了。修改的方式非常简单，只需要将查找出来的对象的某个属性进行修改,  然后再调用这个对象的save方法便可以进行修改 

```
from datetime import datetime
book = Book.objects.get(name='三国演义')
book.pub_date = datetime.now()
book.save()
```


# 4 删除数据 

在查找到数据后，便可以进行删除了。删除数据非常简单，只需要调用这个对象的delete 方法即可。实例代码如下：


```
book = Book.objects.get(name='三国演义')
book.delete()
```


# 5 查询操作详细解说

查找是数据库操作中一个非常重要的技术。查询一般就是使用filter 、exclude 以及get 三个方法来实现。我们可以在调用这些方法的时候传递不同的参数来实现查询需求。

在ORM 层面，这些查询条件都是使用 `field + __ + condition` 的方式来使用的。以下将那些常用的查询条件来一一解释

pub_time, pub_time__exact, 

> 需要注意的时候, 在自己定义 field 的时候, 不要加上两个 `_`, 这样会 和 `field + __ + condition` 的查询方式 引起歧义


## 5.1 查询条件 

1 exact：
使用精确的= 进行查找。如果提供的是一个None ，那么在SQL 层面就是被解释为NULL 。

```
article = Article.objects.get(id__exact=14)
article = Article.objects.get(id__exact=None)
```

以上的两个查找在翻译为SQL 语句为如下：

```
select ... from article where id=14;
select ... from article where id IS NULL;
```


![](images/Pasted%20image%2020240617155911.png)

![](images/Pasted%20image%2020240617155959.png)


print(article 的结果 )
![](images/Pasted%20image%2020240617160034.png)



2 iexact
使用like 进行查找。示例代码如下：

`article = Article.objects.filter(title__iexact='hello world')`

那么以上的查询就等价于以下的SQL 语句：
`select ... from article where title like 'hello world';`

注意上面这个sql 语句，因为在MySQL 中，没有一个叫做ilike 的。所以exact 和iexact 的区别实际上就是LIKE 和= 的区别，在大部分collation=utf8_general_ci 情况下都是一样的（ collation 是用来对字符串比较的）



3 contains
大小写敏感，判断某个字段是否包含了某个数据。示例代码如下：
`articles = Article.objects.filter(title__contains='hello')`

在翻译成SQL 语句为如下：
`select ... where title like binary '%hello%';`

要注意的是，在使用contains 的时候，翻译成的sql 语句左右两边是有百分号的，意味着使用的是模糊查询。而exact 翻译成sql 语句左右两边是没有百分号的，意味着使用的是精确的查询。




4 icontains
大小写不敏感的匹配查询。示例代码如下：
`articles = Article.objects.filter(title__icontains='hello')`

在翻译成SQL 语句为如下：
`select ... where title like '%hello%';`



5 in
提取那些给定的field 的值是否在给定的容器中。容器可以为list 、tuple 或者任何一个可以迭代的对象，包括QuerySet 对象。示例代码如下：

`articles = Article.objects.filter(id__in=[1,2,3])`

以上代码在翻译成SQL 语句为如下：
`select ... where id in (1,3,4)`

当然也可以传递一个QuerySet 对象进去。示例代码如下：

```
inner_qs = Article.objects.filter(title__contains='hello')
categories = Category.objects.filter(article__in=inner_qs)
```

以上代码的意思是获取那些文章标题包含hello 的所有分类。
将翻译成以下sql语句, 

`select ...from category where article.id in (select id from article where title like '%hello%');`



6 gt

某个field 的值要大于给定的值。示例代码如下：
`articles = Article.objects.filter(id__gt=4)`

以上代码的意思是将所有id 大于4的文章全部都找出来。
将翻译成以下SQL 语句：

`select ... where id > 4;`


7 gte
类似于gt ，是大于等于。


8 lt
类似于gt是小于 


9lte：
类似于lt ，是小于等于


10 startswith：
判断某个字段的值是否是以某个值开始的。大小写敏感。示例代码如下：
`articles = Article.objects.filter(title__startswith='hello')`

以上代码的意思是提取所有标题以hello 字符串开头的文章。
将翻译成以下SQL 语句
`select ... where title like 'hello%'`


11 istartswith：
类似于startswith ，但是大小写是不敏感的。


12 endswith：
判断某个字段的值是否以某个值结束。大小写敏感。示例代码如下：
`articles = Article.objects.filter(title__endswith='world')`

以上代码的意思是提取所有标题以world 结尾的文章。
select ... where title like '%world';


13 iendswith
`类似于endswith ，只不过大小写不敏感。`


14 range：

判断某个field 的值是否在给定的区间中。示例代码如下：
```
from django.utils.timezone import make_aware
from datetime import datetime
start_date = make_aware(datetime(year=2018,month=1,day=1))
end_date = make_aware(datetime(year=2018,month=3,day=29,hour=16))
articles = Article.objects.filter(pub_date__range=(start_date,end_date))
```

以上代码的意思是提取所有发布时间在2018/1/1 到2018/12/12 之间的文章。
将翻译成以下的SQL 语句：

`select ... from article where pub_time between '2018-01-01' and '2018-12-12'。`

需要注意的是，以上提取数据，不会包含最后一个值。也就是不会包含2018/12/12 的文章。


15 date
针对某些date 或者datetime 类型的字段。可以指定date 的范围。并且这个时间过滤，还可以使用链式调用
articles = Article.objects.filter(pub_date__date=date(2018,3,29))

以上代码的意思是查找时间为2018/3/29 这一天发表的所有文章。
```
select ... WHERE DATE(CONVERT_TZ(`front_article`.`pub_date`, 'UTC', 'Asia/Shanghai')) = 2018-03-29
```


16 year 
根据年份进行查找。示例代码如下：
articles = Article.objects.filter(pub_date__year=2018)
articles = Article.objects.filter(pub_date__year__gte=2017)


以上的代码在翻译成SQL 语句为如下：
select ... where pub_date between '2018-01-01' and '2018-12-31';
select ... where pub_date >= '2017-01-01';
articles = Article.objects.filter(pub_date__time=datetime.time(12,12,12));


17 month：
同year ，根据月份进行查找。


18 day：
同year ，根据日期进行查找。


19 week_day：
Django 1.11 新增的查找方式。同year ，根据星期几进行查找。1表示星期天，7表示星期六， 2-6 代表的是星期一到星期五。


20 time：
根据时间进行查找。示例代码如下：
articles = Article.objects.filter(pub_date__time=datetime.time(12,12,12));

以上的代码是获取每一天中12点12分12秒发表的所有文章。


21 isnull
根据值是否为空进行查找。示例代码如下：
articles = Article.objects.filter(pub_date__isnull=False)

以上的代码的意思是获取所有发布日期不为空的文章。
将来翻译成SQL 语句如

`select ... where pub_date is not null;`

22 regex和iregex
大小写敏感和大小写不敏感的正则表达式。示例代码如下：
articles = Article.objects.filter(title__regex=r'^hello')

以上代码的意思是提取所有标题以hello 字符串开头的文章。
将翻译成以下的SQL 语句：
select ... where title regexp binary '^hello';


23 根据关联的表进行查询 
假如现在有两个ORM 模型，一个是Article ，一个是Category 。代码如下：

```
class Category(models.Model):
    """文章分类表"""
    name = models.CharField(max_length=100)
    
class Article(models.Model):
    """文章表"""
    title = models.CharField(max_length=100,null=True)
    category = models.ForeignKey("Category",on_delete=models.CASCADE)
```

比如想要获取文章标题中包含"hello"的所有的分类。那么可以通过以下代码来实现：
`categories = Category.object.filter(article__title__contains("hello"))`


### 5.1.1 例子

Project: database_demo 

database_demo/database_demo  的 urls.py
```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('book/', include("book.urls")),
    path('article/', include("article.urls")),
    path('front/', include('front.urls'))
]
```


Article 这个app

article/urls.py
```python
from django.urls import path  
from . import views  
  
app_name = 'article'  
  
urlpatterns = [  
    path('test', views.article_test, name='article_test'),  
    path('onetomany', views.one_to_many, name='one_to_many'),  
    path('query1', views.query1, name='query1'),  
    path('query2', views.query2, name='query2'),  
    path('query3', views.query3, name='query3'),  
    path('query4', views.query4, name='query4'),  
    path('query5', views.query5, name='query5'),  
]
```


article/views.py 
```python
from datetime import datetime  
  
from django.shortcuts import HttpResponse  
from .models import User, Article  
  
# Create your views here.  
def article_test(request):  
    # user = User(username='知了', password='111111')  
    # user.save()    # article = Article(title='ChatGpt5已经发布啦！', content='xxx', author=user)  
    # article.save()    article = Article.objects.first()  
    return HttpResponse(article.author.username)  
  
  
def one_to_many(request):  
    user = User.objects.first()  
    articles = user.articles.filter(title__contains='XX').all()  
    for article in articles:  
        print(article.title)  
    return HttpResponse("成功！")  
  
  
def query1(reqeust):  
    # article = Article.objects.filter(id__exact=1)  
    # 查询结果.query看到，article.query，就可以看到底层执行的sql语句  
    article = Article.objects.filter(title__iexact='chatgpt5已经发布啦！')  
    print(article.query)  
    print(article)  
    return HttpResponse("xx")  
  
  
def query2(request):  
    # article = Article.objects.filter(title__contains='chat')  
    article = Article.objects.filter(title__icontains='chat')  
    print(article.query)  
    print(article)  
    return HttpResponse('query2')  
  
  
  
def query3(request):  
    # article = Article.objects.filter(title__contains='chat')  
    article = Article.objects.filter(id__in=[1,2,3])  
    print(article.query)  
    print(article)  
    return HttpResponse('query3')  
  
  
def query4(request):  
    # article = Article.objects.filter(title__contains='chat')  
    start_date = datetime(year=2024, month=4, day=1)  
    end_date = datetime(year=2024, month=4, day=2)  
    article = Article.objects.filter(pub_time__range=(start_date, end_date))  
    print(article.query)  
    print(article)  
    return HttpResponse('query4')  
  
  
def query5(request):  
    # 查找标题中，包含chat的文章的用户  
    user = User.objects.filter(articles__title__icontains='chat')  
    print(user.query)  
    print(user)  
    return HttpResponse('query5')
```





## 5.2 聚合函数 

如果你用原生SQL ，则可以使用聚合函数来提取数据。比如提取某个商品销售的数量，那么可以使用Count ，如果想要知道商品销售的平均价格，那么可以使用Avg 。

聚合函数是通过aggregate 方法来实现的。在讲解这些聚合函数的用法的时候，都是基于以下的模型对象来实现的

```
from django.db import models

class Author(models.Model):
    """作者模型"""
    name = models.CharField(max_length=100)
    age = models.IntegerField()
    email = models.EmailField()
    
    class Meta:
        db_table = 'author'

class Publisher(models.Model):
    """出版社模型"""
    name = models.CharField(max_length=300)
    
    class Meta:
        db_table = 'publisher'

class Book(models.Model):
    """图书模型"""
    name = models.CharField(max_length=300)
    pages = models.IntegerField()
    price = models.FloatField()
    rating = models.FloatField()
    author = models.ForeignKey(Author,on_delete=models.CASCADE)
    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)
    
    class Meta:
        db_table = 'book'
        
class BookOrder(models.Model):
    """图书订单模型"""
    book = models.ForeignKey("Book",on_delete=models.CASCADE)
    price = models.FloatField()
    
    class Meta:
        db_table = 'book_order'
```

1 AVG 求平均值

比如想要获取所有图书的价格平均值。那么可以使用以下代码实现。

```
from django.db.models import Avg
result = Book.objects.aggregate(Avg('price'))
print(result)
```

以上的打印结果是：
```
{"price__avg":23.0}
```

其中price__avg 的结构是根据field__avg 规则构成的。如果想要修改默认的名字，那么可以将Avg 赋值给一个关键字参数

```
from django.db.models import Avg
result = Book.objects.aggregate(my_avg=Avg('price'))
print(result)
```

那么以上的结果打印为：`{"my_avg":23}`


---
2 
Count：获取指定的对象的个数。

```
from django.db.models import Count
result = Book.objects.aggregate(book_num=Count('id'))
```

以上的result 将返回Book 表中总共有多少本图书。

Count 类中，还有另外一个参数叫做distinct ，默认是等于False ，如果是等于True ，那么将去掉那些重复的值。比如要获取作者表中所有的不重复的邮箱总共有多少个，那么可以通过以下代码来实现

```
from djang.db.models import Count
result = Author.objects.aggregate(count=Count('email',distinct=True))
```


---

3 
Max和Min：获取指定对象的最大值和最小值

比如想要获取Author 表中，最大的年龄和最小的年龄分别是多少。那么可以通过以下代码来实现：

```
from django.db.models import Max,Min
result = Author.objects.aggregate(Max('age'),Min('age'))
```

如果最大的年龄是88,最小的年龄是18。那么以上的result将为：
`{"age__max":88,"age__min":18}`

---

4 
Sum：求指定对象的总和
比如要求图书的销售总额。那么可以使用以下代码实现：

```
from djang.db.models import Sum
result =
Book.objects.annotate(total=Sum("bookstore__price")).values("name","total")
```

以上的代码annotate 的意思是给Book 表在查询的时候添加一个字段叫做total ，这个字段的数据来源 是从BookStore 模型的price 的总和而来。values 方法是只提取name 和total 两个字段的值。

![](images/Pasted%20image%2020240617163032.png)


### 5.2.1 例子 

front/urls.py

```python 
from django.urls import path  
from . import views  
  
urlpatterns = [  
    path('avg', views.avg_view, name='avg_view'),  
    path('count', views.count_view, name='count_view'),  
    path('maxmin', views.max_min_view, name='maxmin_view'),  
    path('sum', views.sum_view, name='sum_view'),  
    path('f', views.f_view, name='f_view'),  
    path('q', views.q_view, name='q_view'),  
]
```


front/views/py

```python
from django.shortcuts import render, HttpResponse
from django.db.models import Avg, Count, Max, Min, Sum, F, Q
from .models import Book, BookOrder, Publisher, Author

# Create your views here.
def avg_view(request):
    result = Book.objects.aggregate(avg_price=Avg('price'))
    print(result)
    return HttpResponse("avg view")


def count_view(request):
    result = Book.objects.aggregate(book_count=Count('id'))
    print(result)
    return HttpResponse("count_view")


def max_min_view(request):
    result = Author.objects.aggregate(max_age=Max('age'), min_age=Min('age'))
    print(result)
    return HttpResponse("max_min_view")


def sum_view(request):
    result = Book.objects.annotate(total=Sum("bookorder__price")).values('name', 'total')
    print(result)
    return HttpResponse("sum_view")


def f_view(request):
    Book.objects.update(price=F('price')-10)
    return HttpResponse("f view")


def q_view(request):
    books = Book.objects.filter(Q(price__gte=87) | Q(rating__gte=9)).all()
    for book in books:
        print(book.name, book.price, book.rating)
    return HttpResponse("q view")
```

## 5.3 aggregate和annotate的区别

aggregate ：返回使用聚合函数后的字段和值。

annotate ：在原来模型字段的基础之上添加一个使用了聚合函数的字段，并且在使用聚合函数的时候，会使用当前这个模型的主键进行分组（group by）。(自动就把这个table 的主键 给找出来了)
比如以上Sum 的例子，如果使用的是annotate ，那么将在每条图书的数据上都添加一个字段叫做 total ，计算这本书的销售总额。
而如果使用的是aggregate ，那么将求所有图书的销售总额。



## 5.4 F表达式和Q表达式 


### 5.4.1 F表达式 

F表达式是用来优化ORM 操作数据库的。比如我们要将公司所有员工的薪水都增加1000元，如果按照正 常的流程，应该是先从数据库中提取所有的员工工资到Python内存中，然后使用Python代码在员工工资 的基础之上增加1000元，最后再保存到数据库中。这里面涉及的流程就是，首先从数据库中提取数据到 Python内存中，然后在Python内存中做完运算，之后再保存到数据库中。

示例代码如下：

```
employees = Employee.objects.all()
for employee in employees:
    employee.salary += 1000
    employee.save()
```

而我们的F表达式就可以优化这个流程，他可以不需要先把数据从数据库中提取出来，计算完成后再保存回去，他可以直接执行SQL语句，就将员工的工资增加1000元。

```
from djang.db.models import F
Employee.object.update(salary=F("salary")+1000)
```

F表达式并不会马上从数据库中获取数据，而是在生成SQL 语句的时候，动态的获取传给F表达式的值。

比如如果想要获取作者中， name 和email 相同的作者数据。如果不使用F表达式，那么需要使用以下代码来完成：

```
authors = Author.objects.all()
for author in authors:
    if author.name == author.email:
        print(author)
```


如果使用F表达式，那么一行代码就可以搞定。

```
from django.db.models import F
authors = Author.objects.filter(name=F("email"))
```


### 5.4.2 Q表达式

如果想要实现所有价格高于100元，`并且`评分达到9.0以上评分的图书。那么可以通过以下代码来实现：

```
books = Book.objects.filter(price__gte=100,rating__gte=9)
```

以上这个案例是一个并集查询，可以简单的通过传递多个条件进去来实现。
但是如果想要实现一些复杂的查询语句，比如要查询所有价格低于10元，`或者`是评分低于9分的图书。那就没有办法通过传递多个条件进去实现了。这时候就需要使用Q表达式来实现了

```
from django.db.models import Q
books = Book.objects.filter(Q(price__lte=10) | Q(rating__lte=9))
```

以上是进行或运算，当然还可以进行其他的运算，比如有& 和~（非） 等。一些用Q 表达式的例子如下：

```
from django.db.models import Q

# 获取id等于3的图书
books = Book.objects.filter(Q(id=3))

# 获取id等于3，或者名字中包含文字"记"的图书
books = Book.objects.filter(Q(id=3)|Q(name__contains("记")))

# 获取价格大于100，并且书名中包含"记"的图书
books = Book.objects.filter(Q(price__gte=100)&Q(name__contains("记")))

# 获取书名包含“记”，但是id不等于3的图书
books = Book.objects.filter(Q(name__contains='记') & ~Q(id=3))
```



### 5.4.3 例子

```python
def f_view(request):
    Book.objects.update(price=F('price')-10)
    return HttpResponse("f view")


def q_view(request):
    books = Book.objects.filter(Q(price__gte=87) | Q(rating__gte=9)).all()
    for book in books:
        print(book.name, book.price, book.rating)
    return HttpResponse("q view")
```


![](images/Pasted%20image%2020240617163801.png)


