
在ORM 框架中，所有模型相关的操作，比如添加/删除等。其实都是映射到数据库中一条数据的操作。因此模型操作也就是数据库表中数据的操作


# 1 添加一个模型到数据库中

添加模型到数据库中。首先需要创建一个模型。创建模型的方式很简单，就跟创建普通的Python 对象是一摸一样的。在创建完模型之后，需要调用模型的save 方法，这样Django 会自动的将这个模型转换成sql 语句，然后存储到数据库中。示例代码如下：

```
class Book(models.Model):
    name = models.CharField(max_length=20,null=False)
    desc = models.CharField(max_length=100,name='description',db_column="description1")
    pub_date = models.DateTimeField(auto_now_add=True)

book = Book(name='三国演义',desc='三国英雄！')
book.save()
```

# 2 查找数据 

查找数据都是通过模型下的objects 对象来实现的。

## 2.1 查找所有数据：
要查找Book 这个模型对应的表下的所有数据。那么示例代码如下
`books = Book.objects.all()`

以上将返回Book模型下的所有数据


---
例子
我们来实现下图书信息的查询，顺便通过外键关联配置，把图书类别信息也级联查询出来。我们通过
all()方法查询出所有图书信息；
views.py里我们加下bookList方法：
```
def bookList(request):
	"""
	图书列表查询
	"""
	# 查询所有信息
	bookList = BookInfo.objects.all()
	print(bookList)
	content_value = {"title": "图书列表", "bookList": bookList}
	return render(request, 'book/list.html', context=content_value)
```

urls.py里加下映射配置：
```
path('book/list', helloWorld.views.bookList)
```


templates下新建book目录，book目录下新建list.html
```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>{{ title }}</title>
    </head>
    <body>
        <h3>{{ title }}</h3>
        <table border="1">
            <tr>
                <th>编号</th>
                <th>图书名称</th>
                <th>价格</th>
                <th>出版日期</th>
                <th>图书类别</th>
            </tr>
            {% for book in bookList %}
            <tr>
                <td>{{ book.id }}</td>
                <td>{{ book.bookName }}</td>
                <td>{{ book.price }}</td>
                <td>{{ book.publishDate | date:'Y-m-d' }}</td>
                <td>{{ book.bookType.bookTypeName }}</td>
            </tr>
            {% endfor %}
        </table>
    </body>
</html>
```

测试运行，浏览器输入： http://127.0.0.1:8000/book/list
![[04_模型model_数据库/images/Pasted image 20240619203956.png]]


## 2.2 数据过滤

在查找数据的时候，有时候需要对一些数据进行过滤。那么这时候需要调用objects 的filter 方法。
实例代码如下：

```
books = Book.objects.filter(name='三国演义')
> [<Book:三国演义>]
> 
# 多个条件
books = Book.objects.filter(name='三国演义',desc='test')
```

调用filter ，会将所有满足条件的模型对象都返回。


## 2.3 获取单个对象 

使用filter 返回的是所有满足条件的结果集。有时候如果只需要返回第一个满足条件的对象。那么可以使用get 方法

```
book = Book.objects.get(name='三国演义')
> <Book:三国演义>
```

当然，如果没有找到满足条件的对象，那么就会抛出一个异常。而filter 在没有找到满足条件的数据的时候，是返回一个空的列表。

## 2.4 数据排序


在之前的例子中，数据都是无序的。如果你想在查找数据的时候使用某个字段来进行排序，那么可以使用order_by 方法来实现。

```
books = Book.objects.order_by("pub_date")
```

以上代码在提取所有书籍的数据的时候，将会使用pub_date 从`小到大`进行排序。

如果想要进行倒序排序，那么可以在pub_date 前面加一个负号。
`books = Book.objects.order_by("-pub_date")`

# 3 数据新增

Django对数据库的数据进行增、删、改操作是借助内置ORM框架所提供的API方法实现的,简单来说，它
在模型基础类 Model里定义数据操作方法，通过类继承将这些操作方法传给开发者自定义的模型对象，
再由模型对象调用即可实现数据操作。
添加操作通过模型的save方法实现，添加下可以返回主键id值。
我们在前面实例的基础上，来实现这个例子。
因为添加页面是需要图书类别的数据，我们用下拉框实现。所以这里需要一个预处理操作。


先在views.py里定义一个添加预处理方法preAdd

```python
def preAdd(request):
	"""
	预处理，添加操作
	:param request:
	:return:
	"""
	bookTypeList = BookTypeInfo.objects.all()
	print(bookTypeList)
	content_value = {"title": "图书添加", "bookTypeList": bookTypeList}
	return render(request, 'book/add.html', context=content_value)
```

urls.py里加下映射：
```
path('book/preAdd', helloWorld.views.preAdd),
```

原先的list.html，加上添加的链接：
```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>{{ title }}</title>
    </head>
    <body>
        <h3>{{ title }}</h3>
        <a href="/book/preAdd">添加</a><br />
        <br />
        <table border="1">
            <tr>
                <th>编号</th>
                <th>图书名称</th>
                <th>价格</th>
                <th>出版日期</th>
                <th>图书类别</th>
            </tr>
            {% for book in bookList %}
            <tr>
                <td>{{ book.id }}</td>
                <td>{{ book.bookName }}</td>
                <td>{{ book.price }}</td>
                <td>{{ book.publishDate | date:'Y-m-d' }}</td>
                <td>{{ book.bookType.bookTypeName }}</td>
            </tr>
            {% endfor %}
        </table>
    </body>
</html>

```


再创建下图书添加页面add.html：
```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>{{ title }}</title>
    </head>
    <body>
        <h3>{{ title }}</h3>
        <form action="/book/add" method="post">
            {% csrf_token %}
            <table>
                <tr>
                    <td>图书名称：</td>
                    <td>
                        <input type="text" name="bookName" />
                    </td>
                    最后在views.py里创建图书添加函数add： 运行测试：浏览器输入： http://127.0.0.1:8000/book/list
                </tr>
                <tr>
                    <td>出版日期：</td>
                    <td>
                        <input type="text" name="publishDate" />
                    </td>
                </tr>
                <tr>
                    <td>图书类别：</td>
                    <td>
                        <select name="bookType_id">
                            {% for bookType in bookTypeList %}
                            <option value="{{ bookType.id }}">{{ bookType.bookTypeName }}</option>
                            {% endfor %}
                        </select>
                    </td>
                </tr>
                <tr>
                    <td>图书价格：</td>
                    <td>
                        <input type="text" name="price" />
                    </td>
                </tr>
                <tr>
                    <td colspan="2">
                        <input type="submit" value="提交" />
                    </td>
                </tr>
            </table>
        </form>
    </body>
</html>

```


最后在views.py里创建图书添加函数add：
```
def add(request):
	"""
	图书添加
	:param request:
	:return:
	"""
	# print(request.POST.get("bookName"))
	# print(request.POST.get("publishDate"))
	# print(request.POST.get("bookType_id"))
	# print(request.POST.get("price"))
	book = BookInfo()
	book.bookName = request.POST.get("bookName")
	book.publishDate = request.POST.get("publishDate")
	book.bookType_id = request.POST.get("bookType_id")
	book.price = request.POST.get("price")
	book.save()
	# 数据添加后，获取新增数据的主键id
	print(book.id)
	return bookList(request)
```

运行测试：浏览器输入： http://127.0.0.1:8000/book/list

![[04_模型model_数据库/images/Pasted image 20240619210952.png]]


点击添加链接，

![[04_模型model_数据库/images/Pasted image 20240619211011.png]]

进入图书添加页面，输入图书信息，点提交：
![[04_模型model_数据库/images/Pasted image 20240619211032.png]]





# 4 修改数据 

在查找到数据后，便可以进行修改了。修改的方式非常简单，只需要将查找出来的对象的某个属性进行修改,  然后再调用这个对象的save方法便可以进行修改 

```
from datetime import datetime
book = Book.objects.get(name='三国演义')
book.pub_date = datetime.now()
book.save()
```


----

模型数据修改和添加都是用的save方法。
我们结合案例先实现下；

我们在views.py里先定义preUpdate方法，修改预处理，根据id获取图书信息，以及获取图书类别列表；

```python
def preUpdate(request, id):
	"""
	预处理，修改操作
	:param request:
	:return:
	"""
	print("id:", id)
	book = BookInfo.objects.get(id=id)
	print(book)
	bookTypeList = BookTypeInfo.objects.all()
	print(bookTypeList)
	content_value = {"title": "图书修改", "bookTypeList": bookTypeList, "book":book}
	return render(request, 'book/edit.html', context=content_value)
```

urls.py里加下映射：
`path('book/preUpdate/<int:id>', helloWorld.views.preUpdate),`

book/list.html修改下，加下修改操作链接：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>{{ title }}</title>
    </head>
    <body>
        <h3>{{ title }}</h3>
        <a href="/book/preAdd">添加</a><br />
        <br />
        <table border="1">
            <tr>
                <th>编号</th>
                <th>图书名称</th>
                <th>价格</th>
                <th>出版日期</th>
                <th>图书类别</th>
                <th>操作</th>
            </tr>
            {% for book in bookList %}
            <tr>
                <td>{{ book.id }}</td>
                <td>{{ book.bookName }}</td>
                <td>{{ book.price }}</td>
                <td>{{ book.publishDate | date:'Y-m-d' }}</td>
                <td>{{ book.bookType.bookTypeName }}</td>
                <td>
                    <a href="/book/preUpdate/{{ book.id }}">修改</a>
                </td>
            </tr>
            {% endfor %}
        </table>
    </body>
</html>

```


新建编辑页面edit.html

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>{{ title }}</title>
    </head>
    <body>
        <h3>{{ title }}</h3>
        <form action="/book/update" method="post">
            {% csrf_token %} 再写一个update方法，保存图书信息
            <table>
                <tr>
                    <td>图书名称：</td>
                    <td>
                        <input type="text" name="bookName" value="{{ book.bookName }}" />
                    </td>
                </tr>
                <tr>
                    <td>出版日期：</td>
                    <td>
                        <input
                            type="text"
                            name="publishDate"
                            value="{{ book.publishDate
| date:'Y-m-d' }}"
                        />
                    </td>
                </tr>
                <tr>
                    <td>图书类别：</td>
                    <td>
                        <select name="bookType_id"> 
                        {% for bookType in bookTypeList %}
							<option value="{{ bookType.id }}"
								{% if book.bookType.id == bookType.id%}selected{% endif %}>
								{{ bookType.bookTypeName }}
							</option>
						{% endfor %}
                        </select>
                    </td>
                </tr>
                <tr>
                    <td>图书价格：</td>
                    <td>
                        <input type="text" name="price" value="{{ book.price }}" />
                    </td>
                </tr>
                <tr>
                    <td colspan="2">
                        <input type="hidden" name="id" value="{{ book.id }}" />
                        <input type="submit" value="提交" />
                    </td>
                </tr>
            </table>
        </form>
    </body>
</html>

```


再写一个update方法，保存图书信息
```
def update(request):
	"""
	图书修改
	:param request:
	:return:
	"""
	book = BookInfo()
	book.id = request.POST.get("id")
	book.bookName = request.POST.get("bookName")
	book.publishDate = request.POST.get("publishDate")
	book.bookType_id = request.POST.get("bookType_id")
	book.price = request.POST.get("price")
	book.save()
	return bookList(request)
```

urls.py里再加下映射：
`path('book/update', helloWorld.views.update),`

我们来测试下，浏览器输入： http://127.0.0.1:8000/book/list
![[04_模型model_数据库/images/Pasted image 20240619212322.png]]

我们点修改，修改id是5的图书，

![[04_模型model_数据库/images/Pasted image 20240619212342.png]]

# 5 删除数据 

在查找到数据后，便可以进行删除了。删除数据非常简单，只需要调用这个对象的delete 方法即可。实例代码如下：


```
book = Book.objects.get(name='三国演义')
book.delete()
```


---

Django5 ORM框架提供了delete()方法来实现数据删除操作，下面是一些常用的方式，删除所有数据，
删除指定id数据，根据filter条件删除删除。

```python
# 删除所有数据
BookInfo.objects.all().delete()
# 删除指定id数据
BookInfo.objects.get(id=1).delete()
# 根据条件删除多条数据
BookInfo.objects.filter(price__gte=90).delete()
```

views.py里先定义delete方法。
```python
def delete(request, id):
	"""
	图书删除
	:param request:
	:return:
	"""
	# 删除所有数据
	# BookInfo.objects.all().delete()
	# 删除指定id数据
	BookInfo.objects.get(id=id).delete()
	# 根据条件删除多条数据
	# BookInfo.objects.filter(price__gte=90).delete()
	return bookList(request)
```

urls.py里加下映射：
```
path('book/delete/<int:id>', helloWorld.views.delete),
```

book/list.html里加下删除操作：
```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>{{ title }}</title>
    </head>
    <body>
        <h3>{{ title }}</h3>
        <a href="/book/preAdd">添加</a><br />
        <br />
        <table border="1">
            <tr>
                <th>编号</th>
                <th>图书名称</th>
                <th>价格</th>
                <th>出版日期</th>
                <th>图书类别</th>
                <th>操作</th>
            </tr>
            {% for book in bookList %} 我们测试下，浏览器输入 http://127.0.0.1:8000/book/list 点击删除链接，
            <tr>
                <td>{{ book.id }}</td>
                <td>{{ book.bookName }}</td>
                <td>{{ book.price }}</td>
                <td>{{ book.publishDate | date:'Y-m-d' }}</td>
                <td>{{ book.bookType.bookTypeName }}</td>
                <td>
                    <a href="/book/preUpdate/{{ book.id }}">修改</a>
                    <a href="/book/delete/{{ book.id }}">删除</a>
                </td>
            </tr>
            {% endfor %}
        </table>
    </body>
</html>
```

我们测试下，浏览器输入 http://127.0.0.1:8000/book/list
![[04_模型model_数据库/images/Pasted image 20240619212806.png]]

点击删除链接，
![[04_模型model_数据库/images/Pasted image 20240619212819.png]]


# 6 一些其他常用方法

前面实例我们用了ORM框架提供的all方法，查询所有数据。

![[04_模型model_数据库/images/Pasted image 20240619204316.png]]

下面我们继续学习下ORM框架给我们提供的一些其他常用方法；

```
# 查询所有信息
bookList = BookInfo.objects.all()
# 获取数据集的第一条数据的bookName属性值
print(bookList[0].bookName)
# 返回前2条数据 select * from t_book limit 2
bookList = BookInfo.objects.all()[:2]
# 查询指定字段
bookList = BookInfo.objects.values("bookName", "price")
# 查询指定字段 数据以列表方式返回，列表元素以元组表示
bookList = BookInfo.objects.values_list("bookName", "price")
```

ORM框架提供了get()方法，返回满足条件的单个数据：
```
# 获取单个对象，一般是根据id查询
book = BookInfo.objects.get(id=2)
print(book.bookName)
```

ORM框架提供了filter()方法，返回满足条件的数据：
```
# 返回满足条件id=2的数据，返回类型是列表
bookList = BookInfo.objects.filter(id=2)
bookList = BookInfo.objects.filter(price=100, id=1)
# filter的查询条件可以设置成字典格式
d = dict(price=100, id=1)
bookList = BookInfo.objects.filter(**d)
# SQL的or查询，需要引入Q，from django.db.models import Q
# 语法格式：Q(field=value)|Q(field=value) 多个Q之间用"|"隔开
bookList = BookInfo.objects.filter(Q(id=1) | Q(price=88))
# SQL的不等于查询，在Q查询中用“~”即可
# SQL select * from t_book where not (id=1)
bookList = BookInfo.objects.filter(~Q(id=1))
```


ORM框架提供了exclude()方法，返回不满足条件的数据：
```
# 也可以使用exclude 返回满足条件之外的数据 实现不等于查询
bookList = BookInfo.objects.exclude(id=1)
```

ORM框架提供了count()方法，返回满足查询条件后的数据量：
```
# 使用count()方法，返回满足查询条件后的数据量
t = BookInfo.objects.filter(id=2).count()
print(t)
```


ORM框架提供了distinct()方法，返回去重后的数据：

```
# distinct()方法，返回去重后的数据
bookList = BookInfo.objects.values('bookName').distinct()
print(bookList)
```


ORM框架提供了order_by()方法，对结果进行排序；默认是升序；如果需要降序，只需要在字段前面加 “-”即可；
```
# 使用order_by设置排序
# bookList = BookInfo.objects.order_by("price")
bookList = BookInfo.objects.order_by("-id")
```


ORM框架提供了annotate方法来实现聚合查询，比如数据值求和，求平均值等。
```
# annotate类似于SQL里面的GROUP BY方法
# 如果不设置values，默认对主键进行GROUIP BY分组
# SQL: select bookType_id，SUM(price) AS 'price_sum' from t_book GROUP BY
bookType_id
r = BookInfo.objects.values('bookType').annotate(Sum('price'))
# SQL: select bookType_id，AVG(price) AS 'price_sum' from t_book GROUP BY
bookType_id
r2 = BookInfo.objects.values('bookType').annotate(Avg('price'))
```


# 7 Django5模型分页查询

在Django中实现分页通常使用Paginator 类。以下是一个简单的示例，展示了如何在Django视图中实现分页功能：

```
bookList = BookInfo.objects.all()

# Paginator(object_list ,per_page)
# object_list 结果集/列表
# per_page 每页多少条记录
p = Paginator(bookList, 2)
# 获取第几页的数据

bookListPage = p.page(2)
print("总记录数：", BookInfo.objects.count())
```


# 8 查询操作详细解说

查找是数据库操作中一个非常重要的技术。查询一般就是使用filter 、exclude 以及get 三个方法来实现。我们可以在调用这些方法的时候传递不同的参数来实现查询需求。

在ORM 层面，这些查询条件都是使用 `field + __ + condition` 的方式来使用的。以下将那些常用的查询条件来一一解释

pub_time, pub_time__exact, 

> 需要注意的时候, 在自己定义 field 的时候, 不要加上两个 `_`, 这样会 和 `field + __ + condition` 的查询方式 引起歧义


## 8.1 查询条件 

前面讲了开发中常用的数据查询方法，但有时需要设置不同的查询条件来满足多方面的查询要求。上述的查询条件 filter和 get是使用等值的方法来匹配结果。若想使用大于、不等于或模糊查询的匹配方法，则可在查询条件filter和 get里使用下表的匹配符实现。

在查询数据时可以使用查询条件get或filter实现，但是两者的执行过程存在一定的差异，说明如下。
- 查询条件get:查询字段必须是主键或者唯一约束的字段，并且查询的数据必须存在，如果查询的字段有重复值或者查询的数据不存在，程序就会抛出异常信息。
- 查询条件filter:查询字段没有限制，只要该字段是数据表的某一字段即可。查询结果以列表形式返回，如果查询结果为空（查询的数据在数据表中找不到)，就返回空列表。


匹配符               使用            说明
__exact filter（job__exact='开发') 精确等于，如SQL的like'开发'。
__iexact filter（job__iexact='开发'） 精确等于并忽略大小写。
__contains filter（job__contains='开发'） 模糊匹配，如SQL的like'%荣耀%'。
__icontains filter（job__icontains='开发'） 模糊匹配，忽略大小写。
__gt filter（job__gt=5） 大于。
__gte filter（job__gte=5） 大于等于。
__lt filter（job__lt=5） 小于。
__lte filter（job__lte=5） 小于等于。
__in filter（job__in=[1,2,3]） 判断是否在列表内。
__startswith filter（job__startswith='开发'） 以。。。开头。
__istartswith filter（job__istartswith='开发'） 以。。。开头并忽略大小写。
__endswith filter（job__endswith='开发'） 以。。。结尾。
__iendswith filter（job__iendswith='开发'） 以。。。结尾并忽略大小写。
__range filter（job__range='开发'） 在。。。范围内。
__year filter（job__year='2018'） 日期字段的年份。
__month filter（job__month='12'） 日期字段的月份。
__day filter（job__day=30） 日期字段的天数。
__isnull filter（job__isnull=True/False） 判断是否为空。

```
# 模糊查询图书名称含有"编程"的所有数据
# bookList = BookInfo.objects.filter(bookName__contains='编程')
# 查询图书价格大于等于50的所有数据
bookList = BookInfo.objects.filter(price__gte=50)
```


1 exact：
使用精确的= 进行查找。如果提供的是一个None ，那么在SQL 层面就是被解释为NULL 。

```
article = Article.objects.get(id__exact=14)
article = Article.objects.get(id__exact=None)
```

以上的两个查找在翻译为SQL 语句为如下：

```
select ... from article where id=14;
select ... from article where id IS NULL;
```


![](04_模型model_数据库/images/Pasted%20image%2020240617155911.png)

![](04_模型model_数据库/images/Pasted%20image%2020240617155959.png)


print(article 的结果 )
![](04_模型model_数据库/images/Pasted%20image%2020240617160034.png)



2 iexact
使用like 进行查找。示例代码如下：

`article = Article.objects.filter(title__iexact='hello world')`

那么以上的查询就等价于以下的SQL 语句：
`select ... from article where title like 'hello world';`

注意上面这个sql 语句，因为在MySQL 中，没有一个叫做ilike 的。所以exact 和iexact 的区别实际上就是LIKE 和= 的区别，在大部分collation=utf8_general_ci 情况下都是一样的（ collation 是用来对字符串比较的）



3 contains
大小写敏感，判断某个字段是否包含了某个数据。示例代码如下：
`articles = Article.objects.filter(title__contains='hello')`

在翻译成SQL 语句为如下：
`select ... where title like binary '%hello%';`

要注意的是，在使用contains 的时候，翻译成的sql 语句左右两边是有百分号的，意味着使用的是模糊查询。而exact 翻译成sql 语句左右两边是没有百分号的，意味着使用的是精确的查询。



4 icontains
大小写不敏感的匹配查询。示例代码如下：
`articles = Article.objects.filter(title__icontains='hello')`

在翻译成SQL 语句为如下：
`select ... where title like '%hello%';`



5 in
提取那些给定的field 的值是否在给定的容器中。容器可以为list 、tuple 或者任何一个可以迭代的对象，包括QuerySet 对象。示例代码如下：

`articles = Article.objects.filter(id__in=[1,2,3])`

以上代码在翻译成SQL 语句为如下：
`select ... where id in (1,3,4)`

当然也可以传递一个QuerySet 对象进去。示例代码如下：

```
inner_qs = Article.objects.filter(title__contains='hello')
categories = Category.objects.filter(article__in=inner_qs)
```

以上代码的意思是获取那些文章标题包含hello 的所有分类。
将翻译成以下sql语句, 

`select ...from category where article.id in (select id from article where title like '%hello%');`



6 gt

某个field 的值要大于给定的值。示例代码如下：
`articles = Article.objects.filter(id__gt=4)`

以上代码的意思是将所有id 大于4的文章全部都找出来。
将翻译成以下SQL 语句：

`select ... where id > 4;`


7 gte
类似于gt ，是大于等于。


8 lt
类似于gt是小于 


9lte：
类似于lt ，是小于等于


10 startswith：
判断某个字段的值是否是以某个值开始的。大小写敏感。示例代码如下：
`articles = Article.objects.filter(title__startswith='hello')`

以上代码的意思是提取所有标题以hello 字符串开头的文章。
将翻译成以下SQL 语句
`select ... where title like 'hello%'`


11 istartswith：
类似于startswith ，但是大小写是不敏感的。


12 endswith：
判断某个字段的值是否以某个值结束。大小写敏感。示例代码如下：
`articles = Article.objects.filter(title__endswith='world')`

以上代码的意思是提取所有标题以world 结尾的文章。
select ... where title like '%world';


13 iendswith
`类似于endswith ，只不过大小写不敏感。`


14 range：

判断某个field 的值是否在给定的区间中。示例代码如下：
```
from django.utils.timezone import make_aware
from datetime import datetime
start_date = make_aware(datetime(year=2018,month=1,day=1))
end_date = make_aware(datetime(year=2018,month=3,day=29,hour=16))
articles = Article.objects.filter(pub_date__range=(start_date,end_date))
```

以上代码的意思是提取所有发布时间在2018/1/1 到2018/12/12 之间的文章。
将翻译成以下的SQL 语句：

`select ... from article where pub_time between '2018-01-01' and '2018-12-12'。`

需要注意的是，以上提取数据，不会包含最后一个值。也就是不会包含2018/12/12 的文章。


15 date
针对某些date 或者datetime 类型的字段。可以指定date 的范围。并且这个时间过滤，还可以使用链式调用
articles = Article.objects.filter(pub_date__date=date(2018,3,29))

以上代码的意思是查找时间为2018/3/29 这一天发表的所有文章。
```
select ... WHERE DATE(CONVERT_TZ(`front_article`.`pub_date`, 'UTC', 'Asia/Shanghai')) = 2018-03-29
```


16 year 
根据年份进行查找。示例代码如下：
articles = Article.objects.filter(pub_date__year=2018)
articles = Article.objects.filter(pub_date__year__gte=2017)


以上的代码在翻译成SQL 语句为如下：
select ... where pub_date between '2018-01-01' and '2018-12-31';
select ... where pub_date >= '2017-01-01';
articles = Article.objects.filter(pub_date__time=datetime.time(12,12,12));


17 month：
同year ，根据月份进行查找。


18 day：
同year ，根据日期进行查找。


19 week_day：
Django 1.11 新增的查找方式。同year ，根据星期几进行查找。1表示星期天，7表示星期六， 2-6 代表的是星期一到星期五。


20 time：
根据时间进行查找。示例代码如下：
articles = Article.objects.filter(pub_date__time=datetime.time(12,12,12));

以上的代码是获取每一天中12点12分12秒发表的所有文章。


21 isnull
根据值是否为空进行查找。示例代码如下：
articles = Article.objects.filter(pub_date__isnull=False)

以上的代码的意思是获取所有发布日期不为空的文章。
将来翻译成SQL 语句如

`select ... where pub_date is not null;`

22 regex和iregex
大小写敏感和大小写不敏感的正则表达式。示例代码如下：
articles = Article.objects.filter(title__regex=r'^hello')

以上代码的意思是提取所有标题以hello 字符串开头的文章。
将翻译成以下的SQL 语句：
select ... where title regexp binary '^hello';


23 根据关联的表进行查询 
假如现在有两个ORM 模型，一个是Article ，一个是Category 。代码如下：

```
class Category(models.Model):
    """文章分类表"""
    name = models.CharField(max_length=100)
    
class Article(models.Model):
    """文章表"""
    title = models.CharField(max_length=100,null=True)
    category = models.ForeignKey("Category",on_delete=models.CASCADE)
```

比如想要获取文章标题中包含"hello"的所有的分类。那么可以通过以下代码来实现：
`categories = Category.object.filter(article__title__contains("hello"))`


### 8.1.1 例子

Project: database_demo 

database_demo/database_demo  的 urls.py
```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('book/', include("book.urls")),
    path('article/', include("article.urls")),
    path('front/', include('front.urls'))
]
```


Article 这个app

article/urls.py
```python
from django.urls import path  
from . import views  
  
app_name = 'article'  
  
urlpatterns = [  
    path('test', views.article_test, name='article_test'),  
    path('onetomany', views.one_to_many, name='one_to_many'),  
    path('query1', views.query1, name='query1'),  
    path('query2', views.query2, name='query2'),  
    path('query3', views.query3, name='query3'),  
    path('query4', views.query4, name='query4'),  
    path('query5', views.query5, name='query5'),  
]
```


article/views.py 
```python
from datetime import datetime  
  
from django.shortcuts import HttpResponse  
from .models import User, Article  
  
# Create your views here.  
def article_test(request):  
    # user = User(username='知了', password='111111')  
    # user.save()    # article = Article(title='ChatGpt5已经发布啦！', content='xxx', author=user)  
    # article.save()    article = Article.objects.first()  
    return HttpResponse(article.author.username)  
  
  
def one_to_many(request):  
    user = User.objects.first()  
    articles = user.articles.filter(title__contains='XX').all()  
    for article in articles:  
        print(article.title)  
    return HttpResponse("成功！")  
  
  
def query1(reqeust):  
    # article = Article.objects.filter(id__exact=1)  
    # 查询结果.query看到，article.query，就可以看到底层执行的sql语句  
    article = Article.objects.filter(title__iexact='chatgpt5已经发布啦！')  
    print(article.query)  
    print(article)  
    return HttpResponse("xx")  
  
  
def query2(request):  
    # article = Article.objects.filter(title__contains='chat')  
    article = Article.objects.filter(title__icontains='chat')  
    print(article.query)  
    print(article)  
    return HttpResponse('query2')  
  
  
  
def query3(request):  
    # article = Article.objects.filter(title__contains='chat')  
    article = Article.objects.filter(id__in=[1,2,3])  
    print(article.query)  
    print(article)  
    return HttpResponse('query3')  
  
  
def query4(request):  
    # article = Article.objects.filter(title__contains='chat')  
    start_date = datetime(year=2024, month=4, day=1)  
    end_date = datetime(year=2024, month=4, day=2)  
    article = Article.objects.filter(pub_time__range=(start_date, end_date))  
    print(article.query)  
    print(article)  
    return HttpResponse('query4')  
  
  
def query5(request):  
    # 查找标题中，包含chat的文章的用户  
    user = User.objects.filter(articles__title__icontains='chat')  
    print(user.query)  
    print(user)  
    return HttpResponse('query5')
```



## 8.2 多表查询 

我们在日常的开发中，常常需要对多张数据表同时进行数据查询。多表查询需要在数据表之间建立表关系才能够实现。一对多或一对一的表关系是通过外键实现关联的，而多表查询分为正向查询和反向查询。

以模型BookInfo和BokkTypeInfo为例，如果查询主题是BookInfo，通过外键bookType_id去查询BooKTypeInfo的关联数据，那么该查询称为正向查询；如果查询对象的主题是模型BookTypeInfo，要查询它与模型BookInfo的关联数据，那么该查询称为反向查询；

```
def bookList2(request):
	"""
	多表查询 正常查询 和反向查询
	:param request:
	:return:
	"""
	# 正向查询
	book: BookInfo = BookInfo.objects.filter(id=2).first()
	print(book.bookType.bookTypeName)
	
	# 反向查询
	bookType = BookTypeInfo.objects.filter(id=1).first()
	print(bookType.bookinfo_set.first().bookName)
	print(bookType.bookinfo_set.all())
	content_value = {"title": "图书列表"}
	return render(request, 'book/list.html')
```




## 8.3 聚合函数 

如果你用原生SQL ，则可以使用聚合函数来提取数据。比如提取某个商品销售的数量，那么可以使用Count ，如果想要知道商品销售的平均价格，那么可以使用Avg 。

聚合函数是通过aggregate 方法来实现的。在讲解这些聚合函数的用法的时候，都是基于以下的模型对象来实现的

```
from django.db import models

class Author(models.Model):
    """作者模型"""
    name = models.CharField(max_length=100)
    age = models.IntegerField()
    email = models.EmailField()
    
    class Meta:
        db_table = 'author'

class Publisher(models.Model):
    """出版社模型"""
    name = models.CharField(max_length=300)
    
    class Meta:
        db_table = 'publisher'

class Book(models.Model):
    """图书模型"""
    name = models.CharField(max_length=300)
    pages = models.IntegerField()
    price = models.FloatField()
    rating = models.FloatField()
    author = models.ForeignKey(Author,on_delete=models.CASCADE)
    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)
    
    class Meta:
        db_table = 'book'
        
class BookOrder(models.Model):
    """图书订单模型"""
    book = models.ForeignKey("Book",on_delete=models.CASCADE)
    price = models.FloatField()
    
    class Meta:
        db_table = 'book_order'
```

1 AVG 求平均值

比如想要获取所有图书的价格平均值。那么可以使用以下代码实现。

```
from django.db.models import Avg
result = Book.objects.aggregate(Avg('price'))
print(result)
```

以上的打印结果是：
```
{"price__avg":23.0}
```

其中price__avg 的结构是根据field__avg 规则构成的。如果想要修改默认的名字，那么可以将Avg 赋值给一个关键字参数

```
from django.db.models import Avg
result = Book.objects.aggregate(my_avg=Avg('price'))
print(result)
```

那么以上的结果打印为：`{"my_avg":23}`


---
2 
Count：获取指定的对象的个数。

```
from django.db.models import Count
result = Book.objects.aggregate(book_num=Count('id'))
```

以上的result 将返回Book 表中总共有多少本图书。

Count 类中，还有另外一个参数叫做distinct ，默认是等于False ，如果是等于True ，那么将去掉那些重复的值。比如要获取作者表中所有的不重复的邮箱总共有多少个，那么可以通过以下代码来实现

```
from djang.db.models import Count
result = Author.objects.aggregate(count=Count('email',distinct=True))
```


---

3 
Max和Min：获取指定对象的最大值和最小值

比如想要获取Author 表中，最大的年龄和最小的年龄分别是多少。那么可以通过以下代码来实现：

```
from django.db.models import Max,Min
result = Author.objects.aggregate(Max('age'),Min('age'))
```

如果最大的年龄是88,最小的年龄是18。那么以上的result将为：
`{"age__max":88,"age__min":18}`

---

4 
Sum：求指定对象的总和
比如要求图书的销售总额。那么可以使用以下代码实现：

```
from djang.db.models import Sum
result =
Book.objects.annotate(total=Sum("bookstore__price")).values("name","total")
```

以上的代码annotate 的意思是给Book 表在查询的时候添加一个字段叫做total ，这个字段的数据来源 是从BookStore 模型的price 的总和而来。values 方法是只提取name 和total 两个字段的值。

![](04_模型model_数据库/images/Pasted%20image%2020240617163032.png)


### 8.3.1 例子 

front/urls.py

```python 
from django.urls import path  
from . import views  
  
urlpatterns = [  
    path('avg', views.avg_view, name='avg_view'),  
    path('count', views.count_view, name='count_view'),  
    path('maxmin', views.max_min_view, name='maxmin_view'),  
    path('sum', views.sum_view, name='sum_view'),  
    path('f', views.f_view, name='f_view'),  
    path('q', views.q_view, name='q_view'),  
]
```


front/views/py

```python
from django.shortcuts import render, HttpResponse
from django.db.models import Avg, Count, Max, Min, Sum, F, Q
from .models import Book, BookOrder, Publisher, Author

# Create your views here.
def avg_view(request):
    result = Book.objects.aggregate(avg_price=Avg('price'))
    print(result)
    return HttpResponse("avg view")


def count_view(request):
    result = Book.objects.aggregate(book_count=Count('id'))
    print(result)
    return HttpResponse("count_view")


def max_min_view(request):
    result = Author.objects.aggregate(max_age=Max('age'), min_age=Min('age'))
    print(result)
    return HttpResponse("max_min_view")


def sum_view(request):
    result = Book.objects.annotate(total=Sum("bookorder__price")).values('name', 'total')
    print(result)
    return HttpResponse("sum_view")


def f_view(request):
    Book.objects.update(price=F('price')-10)
    return HttpResponse("f view")


def q_view(request):
    books = Book.objects.filter(Q(price__gte=87) | Q(rating__gte=9)).all()
    for book in books:
        print(book.name, book.price, book.rating)
    return HttpResponse("q view")
```

## 8.4 aggregate和annotate的区别

aggregate ：返回使用聚合函数后的字段和值。

annotate ：在原来模型字段的基础之上添加一个使用了聚合函数的字段，并且在使用聚合函数的时候，会使用当前这个模型的主键进行分组（group by）。(自动就把这个table 的主键 给找出来了)
比如以上Sum 的例子，如果使用的是annotate ，那么将在每条图书的数据上都添加一个字段叫做 total ，计算这本书的销售总额。
而如果使用的是aggregate ，那么将求所有图书的销售总额。


## 8.5 F表达式和Q表达式 


### 8.5.1 F表达式 

F表达式是用来优化ORM 操作数据库的。比如我们要将公司所有员工的薪水都增加1000元，如果按照正 常的流程，应该是先从数据库中提取所有的员工工资到Python内存中，然后使用Python代码在员工工资 的基础之上增加1000元，最后再保存到数据库中。这里面涉及的流程就是，首先从数据库中提取数据到 Python内存中，然后在Python内存中做完运算，之后再保存到数据库中。

示例代码如下：

```
employees = Employee.objects.all()
for employee in employees:
    employee.salary += 1000
    employee.save()
```

而我们的F表达式就可以优化这个流程，他可以不需要先把数据从数据库中提取出来，计算完成后再保存回去，他可以直接执行SQL语句，就将员工的工资增加1000元。

```
from djang.db.models import F
Employee.object.update(salary=F("salary")+1000)
```

F表达式并不会马上从数据库中获取数据，而是在生成SQL 语句的时候，动态的获取传给F表达式的值。

比如如果想要获取作者中， name 和email 相同的作者数据。如果不使用F表达式，那么需要使用以下代码来完成：

```
authors = Author.objects.all()
for author in authors:
    if author.name == author.email:
        print(author)
```


如果使用F表达式，那么一行代码就可以搞定。

```
from django.db.models import F
authors = Author.objects.filter(name=F("email"))
```


### 8.5.2 Q表达式

如果想要实现所有价格高于100元，`并且`评分达到9.0以上评分的图书。那么可以通过以下代码来实现：

```
books = Book.objects.filter(price__gte=100,rating__gte=9)
```

以上这个案例是一个并集查询，可以简单的通过传递多个条件进去来实现。
但是如果想要实现一些复杂的查询语句，比如要查询所有价格低于10元，`或者`是评分低于9分的图书。那就没有办法通过传递多个条件进去实现了。这时候就需要使用Q表达式来实现了

```
from django.db.models import Q
books = Book.objects.filter(Q(price__lte=10) | Q(rating__lte=9))
```

以上是进行或运算，当然还可以进行其他的运算，比如有& 和~（非） 等。一些用Q 表达式的例子如下：

```
from django.db.models import Q

# 获取id等于3的图书
books = Book.objects.filter(Q(id=3))

# 获取id等于3，或者名字中包含文字"记"的图书
books = Book.objects.filter(Q(id=3)|Q(name__contains("记")))

# 获取价格大于100，并且书名中包含"记"的图书
books = Book.objects.filter(Q(price__gte=100)&Q(name__contains("记")))

# 获取书名包含“记”，但是id不等于3的图书
books = Book.objects.filter(Q(name__contains='记') & ~Q(id=3))
```



### 8.5.3 例子

```python
def f_view(request):
    Book.objects.update(price=F('price')-10)
    return HttpResponse("f view")


def q_view(request):
    books = Book.objects.filter(Q(price__gte=87) | Q(rating__gte=9)).all()
    for book in books:
        print(book.name, book.price, book.rating)
    return HttpResponse("q view")
```


![](04_模型model_数据库/images/Pasted%20image%2020240617163801.png)


# 9 ORM执行SQL语句

Django在查询数据时，大多数查询都能使用ORM提供的API方法，但对于一些复杂的查询可能难以使用ORM的API方法实现，因此Django引入了SQL语句的执行方法，有以下3种实现方法。
- extra:结果集修改器，一种提供额外查询参数的机制。
- raw:执行原始SQL并返回模型实例对象。
- execute:直接执行自定义SQL。

1 
extra适合用于ORM难以实现的查询条件，将查询条件使用原生SQL语法实现，此方法需要依靠模型对象，在某程度上可防止SQL注入。它一共定义了6个参数，每个参数说明如下：
- select:添加新的查询字段，即新增并定义模型之外的字段。
- where:设置查询条件。
- params:如果where设置了字符串格式化%s，那么该参数为where提供数值。
- tables:连接其他数据表，实现多表查询。
- order_by:设置数据的排序方式。
- select_params:如果select设置字符串格式化%s，那么该参数为select提供数值。

```
bookList = BookInfo.objects.extra(where=["price>%s"], params=[90])
```

2 
raw只能实现数据查询操作，并且也要依靠模型对象，它一共定义了4个参数，每个参数说明如下：
- raw_query: sQL语句。
- params:如果raw_query设置字符串格式化%s，那么该参数为raw_query提供数值。
- translations:为查询的字段设置别名。
- using:数据库对象，即 Django 所连接的数据库。

`bookList = BookInfo.objects.raw("select * from t_book where price>%s", params=[90])`

3 
execute的语法，它执行SQL语句无须经过Django的ORM框架。我们知道Django连接数据库需要借助第三方模块实现连接过程，如 MySQL的mysqlclient模块和SQLite 的sqlite3模块等，这些模块连接数据库之后，可通过游标的方式来执行SQL语句，而 execute就是使用这种方式执行SQL语句，

```
cursor: CursorDebugWrapper = connection.cursor()
cursor.execute("select count(*) from t_book where price>90")
print(cursor.fetchone())
```


# 10 ORM数据库事务

事务是指作为单个逻辑执行的一系列操作，这些操作具有原子性，即这些操作要么完全执行，要么完全不执行。事务处理可以确保事务性单元内的所有操作都成功完成,否则不会执行数据操作。事务应该具有4个属性:原子性（Atomicity)、一致性（Consistency)、隔离性(Isolation),持久性(Durability)，这4个属性通常称为ACID特性，说明如下。
- 原子性:一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。
- 一致性:事务必须使数据库从某个一致性状态变到另一个一致性状态，一致性与原子性是密切相关的。
- 隔离性:一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他事务是隔离的，各个事务之间不能互相干扰。
- 持久性:持久性也称永久性(Permanence)，指一个事务一旦提交，它对数据库中数据的改变应该是
- 永久性的，其他操作或故障不应该对其有任何影响。

Django5主要有4个事务方法：
atomic():在视图函数或视图类里使用事务。
savepoint():开启事务。
savepoint_rollback():回滚事务。
savepoint_commit():提交事务。


## 10.1 例子
我们先来做一个用户转账的事例：

models.py下新建AccountInfo账户信息模型
```
class AccountInfo(models.Model):
	user = models.CharField(max_length=20)
	account = models.FloatField()
	
	class Meta:
		db_table = "t_account"
		verbose_name = "用户账户信息" # 给模型取个直观的名字
```

然后我们执行： python manage.py makemigrations 生成数据库迁移文件，再执行： python
manage.py migrate 执行迁移文件，同步到数据库中；生成了t_account表


表里，我们加两个测试数据：
![[04_模型model_数据库/images/Pasted image 20240619214637.png]]


views.py里，我们写一个测试转账测试实例：

```python
def transfer2(request):
	"""
	模拟转账
	:param request:
	:return:
	"""
	a1 = AccountInfo.objects.filter(user='张三')
	a1.update(account=F('account') + 100)
	a2 = AccountInfo.objects.filter(user='李四')
	a2.update(account=F('account') - 100)
	return HttpResponse("OK")
```

urls.py里配置下映射：

```
path('transfer2/', helloWorld.views.transfer2),
```

测试，浏览器输入： http://127.0.0.1:8000/transfer2/ ，测试成功。
![[04_模型model_数据库/images/Pasted image 20240619214712.png]]


这里涉及到2个数据库操作，假如第二个数据库操作失败，那张三就多了100，但是李四钱没少，这时候金融账务就对不上了，除了问题。

我们来模拟下吧，转出代码，除以0：
![[04_模型model_数据库/images/Pasted image 20240619214737.png]]

再运行测试下，页面报错，
![[04_模型model_数据库/images/Pasted image 20240619215241.png]]

李四的钱也没被扣，
![[04_模型model_数据库/images/Pasted image 20240619215257.png]]
\
这时候，Django5提供的事务功能就派上用场了。
Django5主要有4个事务方法：
- atomic():在视图函数或视图类里使用事务。
- savepoint():开启事务。
- savepoint_rollback():回滚事务。
- savepoint_commit():提交事务。

我们用上事务，改下代码：

```python
@transaction.atomic
def transfer(request):
	"""
	模拟转账
	:param request:
	:return:
	"""
	# 开启事务
	sid = transaction.savepoint()
	try:
		a1 = AccountInfo.objects.filter(user='张三')
		a1.update(account=F('account') + 100)
		a2 = AccountInfo.objects.filter(user='李四')
		a2.update(account=F('account') - 100 / 0)
		# 提交事务 （如不设置，当程序执行完成后，会自动提交事务）
		transaction.savepoint_commit(sid)
	except Exception as e:
		print("异常信息：", e)
		# 事务回滚
		transaction.savepoint_rollback(sid)
	return HttpResponse("OK")
```

我们再测试下，发现回滚了，钱都没有变化；