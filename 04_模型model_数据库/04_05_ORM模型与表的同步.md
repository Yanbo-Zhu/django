

# 1 数据迁移 

然后我们执行： python manage.py makemigrations 生成数据库迁移文件
所谓的迁移文件, 是类似模型类的迁移类,主要是描述了数据表结构的类文件；

这个生成的迁移文件在migrations目录下；每执行一次，都会生成一个新文件。
![[04_模型model_数据库/images/Pasted image 20240619203644.png]]

再执行： python manage.py migrate 执行迁移文件，同步到数据库中；

数据库里就会生成t_book和t_bookType两个表；
![[04_模型model_数据库/images/Pasted image 20240619203659.png]]


最后我们再搞一些测试数据；
```
INSERT INTO `t_booktype` VALUES (1, '计算机类');
INSERT INTO `t_booktype` VALUES (2, '数学类');

INSERT INTO `t_book` VALUES (1, 'Java编程思想', 100, '2004-03-16', 1);
INSERT INTO `t_book` VALUES (2, 'Head First设计模式', 88, '2020-03-16', 1);
INSERT INTO `t_book` VALUES (3, '数学的秘密', 50, '2019-03-06', 2);

```


# 2 ORM模型同步到表中

迁移命令：
1. makemigrations：将模型生成迁移脚本。模型所在的app ，必须放在settings.py 中的 INSTALLED_APPS 中。这个命令有以下几个常用选项：
    1. app_label：后面可以跟一个或者多个app ，那么就只会针对这几个app生成迁移脚本。如果没有任何的app_label，那么会检查INSTALLED_APPS 中所有的app下的模型，针对每一个app都生成响应的迁移脚本。
    2. --name：给这个迁移脚本指定一个名字。
    3. --empty：生成一个空的迁移脚本。如果你想写自己的迁移脚本，可以使用这个命令来实现一个空的文件，然后自己再在文件中写迁移脚本。
2. migrate：将新生成的迁移脚本。映射到数据库中。创建新的表或者修改表的结构。以下一些常用的选项：
    1. app_label：将某个app 下的迁移脚本映射到数据库中。如果没有指定，那么会将所有在INSTALLED_APPS 中的app 下的模型都映射到数据库中。
    3. app_label migrationname：将某个app 下指定名字的migration 文件映射到数据库中。
    4. --fake：可以将指定的迁移脚本名字添加到数据库中。但是并不会把迁移脚本转换为SQL语句，修改数据库中的表。
    5. --fake-initial：将第一次生成的迁移文件版本号记录在数据库中。但并不会真正的执行迁移脚本。
3. showmigrations：查看某个app下的迁移文件。如果后面没有app，那么将查看INSTALLED_APPS中所有的迁移文件。
4. sqlmigrate：查看某个迁移文件在映射到数据库中的时候，转换的SQL 语句。
	1. python manage.py sqlmigrate polls 0001#展示SQL语句
5. python manage.py check#检查项目中的错误，并不实际进行迁移或者链接数据库的操作。

## 2.1 python manage.py shell

相比较直接输入“python”命令的方式进入Python环境，调用manage.py参数能将DJANGO_SETTINGS_MODULE环境变量导入，它将自动按照mysite/settings.py中的设置，配置好你的python shell环境，这样，你就可以导入和调用任何你项目内的模块了。

或者你也可以这样，先进入一个纯净的python环境，然后启动Django，具体如下：

```
>>> import django  
>>> django.setup()  
```

尝试下面的API吧

```
>>> from polls.models import Question, Choice # 导入我们写的模型类  
  
# 现在系统内还没有questions对象  
>>> Question.objects.all()
```


---

我们假设首页的名字为 FrontPage ，并且我们将在命令行下增加它，让我们熟悉一下命令行的使用

进入 newtest 目录，然后:

```Shell
python manage.py shell
```

进入 python

```Python
>>> from wiki.models import Wiki
>>> page = Wiki(pagename='FrontPage', content='Welcome to Easy Wiki')
>>> page.save()
>>> Wiki.objects.all()
[<Wiki object>]
>>> p = Wiki.objects.all()[0]
>>> p.pagename
'FrontPage'
>>> p.content
'Welcome to Easy Wiki'
```

在 Django 中，对于数据库的记录有两种操纵方式，一种是集合方式，一种是对象方式。集合方式相当于表级操作，可以使用 model.objects 来处理。 objects 对象有一些集合方式的操作，如 all() 会返回全部记录， filter() 会根据条件返回部分记录。而象插入新记录则需要使用记录方式来操作，些时要直接使用 model 类。


# 3 migrations中的迁移版本和数据库中的迁移版本对不 上怎么办

1. 找到哪里不一致，然后使用`python manage.py --fake [版本名字]` ，将这个版本标记为已经映射。
2. 删除指定app 下migrations 和数据库表django_migrations 中和这个app 相关的版本号，然后将模型中的字段和数据库中的字段保持一致，再使用命令python manage.py makemigrations 重新生成一个初始化的迁移脚本，之后再使用命令python manage.py makemigrations --fake-initial 来将这个初始化的迁移脚本标记为已经映射。以后再修改就没有问题了。


# 4 根据已有的表自动生成模型

在实际开发中，有些时候可能数据库已经存在了。如果我们用Django 来开发一个网站，读取的是之前已经存在的数据库中的数据。那么该如何将模型与数据库中的表映射呢？根据旧的数据库生成对应的ORM模型，需要以下几个步骤


## 4.1 通过inspectdb命令, 从已经存在的表自动生成model的class 

Django 给我们提供了一个inspectdb 的命令，可以非常方便的将已经存在的表，自动的生成模型。想要使用inspectdb 自动将表生成模型。首先需要在settings.py 中配置好数据库相关信息。不然就找不到数据库

```
DATABASES = {
    'default': {
    'ENGINE': 'django.db.backends.mysql',
    'NAME': "migrations_demo",
    'HOST': '127.0.0.1',
    'PORT': '3306',
    'USER': 'root',
    'PASSWORD': 'root'
    }
}
```

![](04_模型model_数据库/images/Pasted%20image%2020240617173304.png)

![](04_模型model_数据库/images/Pasted%20image%2020240617173313.png)

那么通过python manage.py inspectdb ，就会将表转换为模型后的代码

```python
from django.db import models

class ArticleArticle(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField(blank=True, null=True)
    create_time = models.DateTimeField(blank=True, null=True)
    author = models.ForeignKey('FrontUserFrontuser', models.DO_NOTHING, blank=True, null=True)

    class Meta:
        managed = False
        db_table = 'article_article'

class ArticleArticleTags(models.Model):
    article = models.ForeignKey(ArticleArticle, models.DO_NOTHING)
    tag = models.ForeignKey('ArticleTag', models.DO_NOTHING)

    class Meta:
        managed = False
        db_table = 'article_article_tags'
        unique_together = (('article', 'tag'),)
        
class ArticleTag(models.Model):
    name = models.CharField(max_length=100)
    
    class Meta:
        managed = False
        db_table = 'article_tag'
    
class FrontUserFrontuser(models.Model):
    username = models.CharField(max_length=100)
    telephone = models.CharField(max_length=11)
    
    class Meta:
        managed = False
        db_table = 'front_user_frontuser'
```

以上代码只是显示在终端。如果想要保存到文件中。那么可以使用> 重定向输出到指定的文件。比如让他输出到models.py 文件中

`python manage.py inspectdb > models.py`

以上的命令，只能在终端执行，不能在pycharm->Tools->Run manage.py Task... 中使用。

如果只是想要转换一个表为模型。那么可以指定表的名字。
`python manage.py inspectdb article_article > models.py`


## 4.2 修正模型：

新生成的ORM 模型有些地方可能不太适合使用。比如模型的名字，表之间的关系等等。那么以下选项还需要重新配置一下：
- 模型名：自动生成的模型，是根据表的名字生成的，可能不是你想要的。这时候模型的名字你可以改成任何你想要的。
- 模型所属app：根据自己的需要，将相应的模型放在对应的app中。放在同一个app中也是没有任何问题的。只是不方便管理。
- 模型外键引用：将所有使用ForeignKey 的地方，模型引用都改成字符串。这样不会产生模型顺序的问题。另外，如果引用的模型已经移动到其他的app中了，那么还要加上这个app的前缀。
- 让Django管理模型：将Meta 下的managed=False 删掉，如果保留这个，那么以后这个模型有任何的修改，使用migrate 都不会映射到数据库中。
- 当有多对多的时候，应该也要修正模型。将中间表注释了，然后使用ManyToManyField 来实现多对多。并且，使用ManyToManyField 生成的中间表的名字可能和数据库中那个中间表的名字不一致，这时候肯定就不能正常连接了。那么可以通过db_table 来指定中间表的名字。

```python 
class Article(models.Model):
    title = models.CharField(max_length=100, blank=True, null=True)
    content = models.TextField(blank=True, null=True)
    author = models.ForeignKey('front.User',models.SET_NULL, blank=True,null=True)

# 使用ManyToManyField模型到表，生成的中间表的规则是：article_tags
# 但现在已经存在的表的名字叫做：article_tag
# 可以使用db_table，指定中间表的名字
tags = models.ManyToManyField("Tag",db_table='article_tag')

class Meta:
    db_table = 'article'
```

- 表名：切记不要修改表的名字。不然映射到数据库中，会发生找不到对应表的错误。


## 4.3 执行命令
python manage.py makemigrations 生成初始化的迁移脚本。方便后面通过ORM 来管理表。这时候还需要执行命令python manage.py migrate --fake-initial ，因为如果不使用--
fake-initial ，那么会将迁移脚本会映射到数据库中。这时候迁移脚本会新创建表，而这个表之前是已经存在了的，所以肯定会报错。此时我们只要将这个0001-initial 的状态修改为已经映
射，而不真正执行映射，下次再migrate 的时候，就会忽略他。


## 4.4 将Django 的核心表映射到数据库中

Django 中还有一些核心的表也是需要创建的。不然有些功能
是用不了的。比如auth 相关表。如果这个数据库之前就是使用Django 开发的，那么这些表就已经存在了。可以不用管了。
如果之前这个数据库不是使用Django 开发的，那么应该使用migrate 命令将Django 中的核心模型映射到数据库中。















