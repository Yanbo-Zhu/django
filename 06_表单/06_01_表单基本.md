
# 1 HTML中的表单：

单纯从前端的html 来说，表单是用来提交数据给服务器的,不管后台的服务器用的是Django 还是PHP 语言还是其他语言。
只要把input 标签放在form 标签中，然后再添加一个提交按钮，那么以后点击提交按钮，就可以将input 标签中对应的值提交给服务器了。

![](images/Pasted%20image%2020240618165226.png)


action=某个url, 在 点击按钮后, 会将东西提交提交各这个url 
method=post, 就是 提交的方式是post 


# 2 Django中的表单

Django 中的表单丰富了传统的HTML 语言中的表单。在Django 中的表单，主要做以下两件事：
1. 渲染表单模板。
2. 表单验证数据是否合法。


# 3 Django中表单的使用流程

![](images/Pasted%20image%2020240618171226.png)

在讲解Django 表单的具体每部分的细节之前。我们首先先来看下整体的使用流程。这里以一个做一个留言板为例。首先我们在后台服务器定义一个表单类，继承自django.forms.Form 。

```
# 请求的method
# 1. GET：用来从服务器上获取数据的
# 2. POST：用来向服务器提交数据
# 3. PUT/DELETE/HEAD
```


forms.py
```python
# forms.py

django import forms

class MessageBoardForm(forms.Form):
    title = forms.CharField(max_length=3,label='标题',min_length=2,error_messages=
{"min_length":'标题字符段不符合要求！'})
    content = forms.CharField(widget=forms.Textarea,label='内容')
    email = forms.EmailField(label='邮箱')
    reply = forms.BooleanField(required=False,label='回复')
```


urls.py
```python
from django.urls import path  
from . import views  
  
urlpatterns = [  
    path('', views.index, name='index'),  
    path('register', views.register_view, name='regsiter'),  
    path('article', views.article_view, name='article view')  
]
```

然后在视图中，根据是GET 还是POST 请求来做相应的操作。如果是GET 请求，那么返回一个空的表单，如果是POST 请求，那么将提交上来的数据进行校验


或者 views.py 也可以写成这样
```python
from django.shortcuts import render, HttpResponse  
from .forms import MessageBoardForm, RegisterForm, ArticleForm  
# 请求验证装饰器  
from django.views.decorators.http import require_http_methods  
import json  
  
# Create your views here.  
# 请求的method  
# 1. GET：用来从服务器上获取数据的  
# 2. POST：用来向服务器提交数据  
# 3. PUT/DELETE/HEAD  

@require_http_methods(['GET','POST'])   # 这里限定了, 要么只能用get请求, 要么只能用post请求 
def index(request):  
    # 如果用GET请求，那么就直接返回一个页面  
    if request.method == 'GET':  
        form = MessageBoardForm()   # 从forms.py中的 MessageBoardForm()  method 
        return render(request, 'index.html', context={'form': form})    # 用 forms.py中的 MessageBoardForm()  method  去渲染 index.html
    else:  
        # 对用post请求提交上来的数据，用表单验证是否满足要求  
        form = MessageBoardForm(request.POST)  
        if form.is_valid():  
            title = form.cleaned_data.get('title')  
            content = form.cleaned_data.get('content')  
            email = form.cleaned_data.get('email')  
            return HttpResponse(f"{title}, {content}, {email}")  
        else:  
            print(form.errors)  
            return HttpResponse("表单验证失败！")
```


第二种写法
```python 
# views.py
class IndexView(View):
    def get(self,request):
        form = MessageBoardForm()
        return render(request,'index.html',{'form':form})  
        
    def post(self,request):
        form = MessageBoardForm(request.POST)
        if form.is_valid():
            title = form.cleaned_data.get('title')
            content = form.cleaned_data.get('content')
            email = form.cleaned_data.get('email')
            reply = form.cleaned_data.get('reply')
            return HttpResponse('success')
        else:
            print(form.errors)
            return HttpResponse('fail')
```


在使用GET 请求的时候，我们传了一个form 给模板，那么以后模板就可以使用form 来生成一个表单的html 代码。
在使用POST 请求的时候，我们根据前端上传上来的数据，构建一个新的表单，这个表单是用来验证数据是否合法的，如果数据都验证通过了，那么我们可以通过cleaned_data 来获取相应的数据。

在模板中渲染表单的HTML 代码如下

templates中的 index.html 
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>front页面</title>
</head>
<body>
<h1>留言板</h1>
<form action="" method="POST">    <!-- action为空, 这样post 之后就会提交到页面所在的url上, 不再对这个url进行补充了 -->
    {{ form }}   <!--在 views.py 中 得到了 form 中的内容, 放置到这里 -->
    <input type="submit" value="提交">
</form>
</body>
</html>
```



```html
<form action="" method="post">
    <table>
        <tr>
            <td></td>
            <td><input type="submit" value="提交"></td>
        </tr>
    </table>
</form>
```

我们在最外面给了一个form 标签，然后在里面使用了table 标签来进行美化，在使用form 对象渲染的时候，使用的是table 的方式，当然还可以使用ul 的方式（ as_ul ），也可以使用p 标签的方式（ as_p ），并且在后面我们还加上了一个提交按钮。这样就可以生成一个表单了


# 4 表单验证 


## 4.1 常用的Field

使用Field 可以是对数据验证的第一步。你期望这个提交上来的数据是什么类型，那么就使用什么类型的Field 。

1 
CharField：
用来接收文本。
参数：
max_length：这个字段值的最大长度。
min_length：这个字段值的最小长度。
required：这个字段是否是必须的。默认是必须的。
error_messages：在某个条件验证失败的时候，给出错误信息。
blank=True: 可传可不传, 只是表单验证时允许为空, 不代表数据库可以为空 

2 EmailField：
用来接收邮件，会自动验证邮件是否合法。
错误信息的key： required 、invalid 。

3 FloatField：
用来接收浮点类型，并且如果验证通过后，会将这个字段的值转换为浮点类型。
参数：
max_value：最大的值。
min_value：最小的值。
错误信息的key： required 、invalid 、max_value 、min_value 。


4 IntegerField：
用来接收整形，并且验证通过后，会将这个字段的值转换为整形。
参数：
max_value：最大的值。
min_value：最小的值。
错误信息的key： required 、invalid 、max_value 、min_value 。


5 URLField：
用来接收url 格式的字符串。
错误信息的key： required 、invalid 。


## 4.2 常用验证器 

在验证某个字段的时候，可以传递一个validators 参数用来指定验证器，进一步对数据进行过滤。验证器有很多，但是很多验证器我们其实已经通过这个Field 或者一些参数就可以指定了。比如 EmailValidator ，我们可以通过EmailField 来指定，比如MaxValueValidator ，我们可以通过 max_value 参数来指定。

以下是一些常用的验证器：
1. MaxValueValidator ：验证最大值。
2. MinValueValidator ：验证最小值。
3. MinLengthValidator ：验证最小长度。
4. MaxLengthValidator ：验证最大长度。
5. EmailValidator ：验证是否是邮箱格式。
6. URLValidator ：验证是否是URL 格式。
7. RegexValidator ：如果还需要更加复杂的验证，那么我们可以通过正则表达式的验证器 RegexValidator 。比如现在要验证手机号码是否合格，那么我们可以通过以下代码实现：

```python
class MyForm(forms.Form):
    telephone = forms.CharField( validators=[ validators.RegexValidator("1[345678]\d{9}",message='请输入正确格式的手机号码！') ] )
```



### 4.2.1 例子

1. forms.py 中的 `    telephone = forms.CharField(validators=[validators.RegexValidator("1[345678]\d{9}",message='请输入正确格式的手机号码！')])`   telephone 这个 必须和  `template/register.html` 中的 `<input type="text" name="telephone" placeholder="请输入手机号码">  `  中的 name 对应的值 *(name="telephone")*  完全一样. 

template/register.html
```html
<!DOCTYPE html>  
<html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <title>注册</title>  
</head>  
<body>  
<form action="" method="POST">  
    <div>        <input type="text" name="telephone" placeholder="请输入手机号码">  
    </div>        <div>  
        <input type="password" name="pwd1" placeholder="请输入密码">  
    </div>        <div>  
        <input type="password" name="pwd2" placeholder="请重复密码">  
    </div>    <input type="submit" value="提交">  
</form>  
</body>  
</html>
```


forms.py
```python
class RegisterForm(forms.Form):
    telephone = forms.CharField(validators=[validators.RegexValidator("1[345678]\d{9}",message='请输入正确格式的手机号码！')])

    def clean_telephone(self):
        telephone = self.cleaned_data.get('telephone')
        exists = User.objects.filter(telephone=telephone).exists()
        
        if exists:
            raise forms.ValidationError("手机号码已经存在！")
        return telephone

    def clean(self):  
        cleaned_data = super().clean()  
        pwd1 = cleaned_data.get('pwd1')  
        pwd2 = cleaned_data.get('pwd2')  
        if pwd1 != pwd2:  
            raise forms.ValidationError("两次密码不一致！")  
        else:  
            return cleaned_data
```

views.py 
```python 
@require_http_methods(['GET', 'POST'])  
def register_view(request):  
    if request.method == 'GET':  
        return render(request, 'register.html')  
    else:  
        form = RegisterForm(request.POST)  
        if form.is_valid():  
            telephone = form.cleaned_data.get('telephone')  
            return HttpResponse(telephone)  
        else:  
            print(json.loads(form.errors.as_json()))  
            return HttpResponse("表单验证失败！")
```


urls.py
```python 
from django.urls import path  
from . import views  
  
urlpatterns = [  
    path('', views.index, name='index'),  
    path('register', views.register_view, name='regsiter'),  
    path('article', views.article_view, name='article view')  
]
```




## 4.3 自定义验证

有时候对一个字段验证，不是一个长度，一个正则表达式能够写清楚的，还需要一些其他复杂的逻辑， 那么我们可以对某个字段，进行自定义的验证。

比如在注册的表单验证中，我们想要验证手机号码是否已经被注册过了，那么这时候就需要在数据库中进行判断才知道。

对某个字段进行自定义的验证方式是，定义一个方法，这个方法的名字定义规则是：` clean_<fieldname>` 。如果验证失败，那么就抛出一个验证错误。比如要验证用户表中手机号码之前是否在数据库中存在，那么可以通过以下代码实现


forms.py
```python
class RegisterForm(forms.Form):
    telephone = forms.CharField(validators=[validators.RegexValidator("1[345678]\d{9}",message='请输入正确格式的手机号码！')])

    def clean_telephone(self):
        telephone = self.cleaned_data.get('telephone')
        exists = User.objects.filter(telephone=telephone).exists()
        
        if exists:
            raise forms.ValidationError("手机号码已经存在！")
        return telephone
```



以上是对某个字段进行验证，如果验证数据的时候，需要针对多个字段进行验证，那么可以重写`clean方法`。
比如要在注册的时候，要判断提交的两个密码是否相等。那么可以使用以下代码来完成
```python
class RegisterForm(forms.Form):
    telephone = forms.CharField(validators=
[validators.RegexValidator("1[345678]\d{9}",message='请输入正确格式的手机号码！')])
    pwd1 = forms.CharField(max_length=12)
    pwd2 = forms.CharField(max_length=12)
    
    def clean(self):
        cleaned_data = super().clean()
        pwd1 = cleaned_data.get('pwd1')
        pwd2 = cleaned_data.get('pwd2')
        
        if pwd1 != pwd2:
            raise forms.ValidationError('两个密码不一致！')
        else
            return cleaned_data
```


template/register.html
```html
<!DOCTYPE html>  
<html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <title>注册</title>  
</head>  
<body>  
<form action="" method="POST">  
    <div>        <input type="text" name="telephone" placeholder="请输入手机号码">  
    </div>        <div>  
        <input type="password" name="pwd1" placeholder="请输入密码">  
    </div>        <div>  
        <input type="password" name="pwd2" placeholder="请重复密码">  
    </div>    <input type="submit" value="提交">  
</form>  
</body>  
</html>
```



## 4.4 提取错误信息

如果验证失败了，那么有一些错误信息是我们需要传给前端的。这时候我们可以通过以下属性来获取：
1. form.errors ：这个属性获取的错误信息是一个包含了html 标签的错误信息。
2. form.errors.get_json_data() ：这个方法获取到的是一个字典类型的错误信息。将某个字段的名字作为key ，错误信息作为值的一个字典。
3. form.errors.as_json() ：这个方法是将form.get_json_data() 返回的字典dump 成json 格式的字符串，方便进行传输。
4. 上述方法获取的字段的错误值，都是一个比较复杂的数据。比如以下：
```
{'username': [{'message': 'Enter a valid URL.', 'code': 'invalid'}, {'message':
'Ensure this value has at most 4 characters (it has 22).', 'code':
'max_length'}]}
```


那么如果我只想把错误信息放在一个列表中，而不要再放在一个字典中。这时候我们可以定义一个方法，把这个数据重新整理一份, 

```python
class MyForm(forms.Form):
    username = forms.URLField(max_length=4)
    
    def get_errors(self):
        errors = self.errors.get_json_data()
        new_errors = {}
        for key,message_dicts in errors.items():
            messages = []
            for message in message_dicts:
                messages.append(message['message'])
            new_errors[key] = messages
        
        return new_errors
```


views.py 
```python 
@require_http_methods(['GET', 'POST'])  
def register_view(request):  
    if request.method == 'GET':  
        return render(request, 'register.html')  
    else:  
        form = RegisterForm(request.POST)  
        if form.is_valid():  
            telephone = form.cleaned_data.get('telephone')  
            return HttpResponse(telephone)  
        else:  
            print(json.loads(form.errors.as_json()))  
            return HttpResponse("表单验证失败！")
```


 

# 5 ModelForm


根据模型 生成一个表单 
## 5.1 基本使用

大家在写表单的时候，会发现表单中的Field 和模型中的Field 基本上是一模一样的，而且表单中需要 验证的数据，也就是我们模型中需要保存的。那么这时候我们就可以将模型中的字段和表单中的字段进行绑定。 比如现在有个Article 的模型


model.py
```python 
from django.db import models
from django.core import validators
class Article(models.Model):
    title = models.CharField(max_length=10,validators=
[validators.MinLengthValidator(limit_value=3)])
    content = models.TextField()
    author = models.CharField(max_length=100)
    category = models.CharField(max_length=100)
    create_time = models.DateTimeField(auto_now_add=True)
```

那么在写表单的时候，就不需要把Article 模型中所有的字段都一个个重复写一遍



```python
from django import forms
class MyForm(forms.ModelForm):
    class Meta:
        model = Article
        fields = "__all__"
```


MyForm 是继承自forms.ModelForm ，然后在表单中定义了一个Meta 类，在Meta 类中指定了 model=Article ，以及`fields="__all__" `，这样就可以将Article 模型中所有的字段都复制过来，进行验证。

如果只想针对其中几个字段进行验证，那么可以给fields 指定一个列表，将需要的字段写进去。比如只想验证title 和content ，那么可以使用以下代码实现

```
from django import forms
class MyForm(forms.ModelForm):
    class Meta:
        model = Article
        fields = ['title','content']
```


如果要验证的字段比较多，只是除了少数几个字段不需要验证，那么可以使用exclude 来代替 fields 。比如我不想验证category ，那么示例代码如下

```
class MyForm(forms.ModelForm):
    class Meta:
        model = Article
        exclude = ['category']
```


## 5.2 例子 


models.py 
```python
from django.db import models  
from django.core import validators  
  
  
# Create your models here.  
class Article(models.Model):  
    title = models.CharField(max_length=200, validators=[validators.MinLengthValidator(limit_value=2)])  
    content = models.TextField(validators=[validators.MinLengthValidator(limit_value=3)])  
    # 指定了auto_now_add=True，那么在表单中可以不用传入这个字段  
    create_time = models.DateTimeField(auto_now_add=True)  
    # blank=True，只是表单验证时允许为空，不代表数据库可以为空  
    category = models.CharField(max_length=100, blank=False)

```

forms.py
```python 
from django import forms  
from django.core import validators  
from .models import Article

class ArticleForm(forms.ModelForm):  
    class Meta:  
        model = Article  
        fields = "__all__"  
        # fields = ['title', 'content']  
        error_messages = {  
            'category': {  
                'required': 'category不能为空！'  
            }  
        }
```


views.py 
```python
@require_http_methods(['GET', 'POST'])  
def article_view(request):  
    if request.method == 'GET':  
        return render(request, 'article.html')  
    else:  
        form = ArticleForm(request.POST)  
        if form.is_valid():  
            # 获取title和content以及create_time，然后创建article模型对象，再存储到数据库中  
            title = form.cleaned_data.get('title')  
            content = form.cleaned_data.get('content')  
            return HttpResponse(f"{title}, {content}")  
        else:  
            print(form.errors)  
            return HttpResponse("表单验证失败！")
```


templates/article.html 
```html
<!DOCTYPE html>  
<html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <title>article</title>  
</head>  
<body>  
<form action="" method="POST">  
    <div>        <input type="text" name="title" placeholder="请输入标题">  
    </div>    <div>        <textarea name="content" placeholder="请输入内容" id="" cols="30" rows="10"></textarea>  
    </div>    <div>        <input type="submit" value="提交">  
    </div></form>  
</body>  
</html>
```



## 5.3 自定义错误信息

使用ModelForm ，因为字段都不是在表单中定义的，而是在模型中定义的，因此一些错误消息无法在字段中定义。那么这时候可以在Meta 类中，定义error_messages ，然后把相应的错误消息写到里面去

```
class MyForm(forms.ModelForm):
    class Meta:
        model = Article
        exclude = ['category']
        error_messages ={
            'title':{
                'max_length': '最多不能超过10个字符！',
                'min_length': '最少不能少于3个字符！'
            },
            'content': {
                'required': '必须输入content！',
            }
}
```



## 5.4 save方法

ModelForm 还有save 方法，可以在验证完成后直接调用save 方法，就可以将这个数据保存到数据库中了

```
form = MyForm(request.POST)
if form.is_valid():
    form.save()
    return HttpResponse('succes')
else:
    print(form.get_errors())
    return HttpResponse('fail')
```


这个方法必须要在clean 没有问题后才能使用，如果在clean 之前使用，会抛出异常。

另外，我们在调用save 方法的时候，如果传入一个commit=False ，那么只会生成这个模型的对象，而不会把这个对象真正的插入到数据库中。比如表单上验证的字段没有包含模型中所有的字段，这时候就可以先创建对象，再根据填充其他字段，把所有字段的值都补充完成后，再保存到数据库中

```
form = MyForm(request.POST)
if form.is_valid():
    article = form.save(commit=False)
    article.category = 'Python'
    article.save()
    return HttpResponse('succes')
else:
    print(form.get_errors())
    return HttpResponse('fail')
```





